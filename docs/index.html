<head>
  <script>
    var raw = [{"id":"4-1342444637943","name":"listener","signiture":"Davis.listener()","type":"method","ctx":{"type":"method","receiver":"Davis","name":"listener","string":"Davis.listener()"},"description":{"full":"<p>A module to bind to link clicks and form submits and turn what would normally be http requests<br />into instances of Davis.Request.  These request objects are then pushed onto the history stack<br />using the Davis.history module.</p>\n\n<p>This module uses Davis.$, which by defualt is jQuery for its event binding and event object normalization.<br />To use Davis with any, or no, JavaScript framework be sure to provide support for all the methods called<br />on Davis.$.</p>","summary":"<p>A module to bind to link clicks and form submits and turn what would normally be http requests<br />into instances of Davis.Request.  These request objects are then pushed onto the history stack<br />using the Davis.history module.</p>","body":"<p>This module uses Davis.$, which by defualt is jQuery for its event binding and event object normalization.<br />To use Davis with any, or no, JavaScript framework be sure to provide support for all the methods called<br />on Davis.$.</p>"},"full_description":"<p>A module to bind to link clicks and form submits and turn what would normally be http requests into instances of Davis.Request.  These request objects are then pushed onto the history stack using the Davis.history module.</p>\n\n<p>This module uses Davis.$, which by defualt is jQuery for its event binding and event object normalization. To use Davis with any, or no, JavaScript framework be sure to provide support for all the methods called on Davis.$.</p>","code":"Davis.listener = function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"5-1342444637943","name":"listen","signiture":"this.listen()","type":"method","ctx":{"type":"method","receiver":"this","name":"listen","string":"this.listen()"},"description":{"full":"<p>Binds to both link clicks and form submits using jQuery's deleagate.</p>\n\n<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>","summary":"<p>Binds to both link clicks and form submits using jQuery's deleagate.</p>","body":"<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>"},"full_description":"<p>Binds to both link clicks and form submits using jQuery's deleagate.</p>\n\n<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>","code":"this.listen = function () {\n    Davis.$(document).delegate(this.settings.formSelector, 'submit', submitHandler)\n    Davis.$(document).delegate(this.settings.linkSelector, 'click', clickHandler)\n  }","params":[],"has_params":false,"tags":[{"type":"see","local":"Davis.App.settings","visibility":"Davis.App.settings"},{"type":"memberOf","parent":"listener"}],"module":false,"parent":"listener","related":{"name":"Davis.App.settings","href":"settings"},"has_related":true},{"id":"6-1342444637943","name":"unlisten","signiture":"this.unlisten()","type":"method","ctx":{"type":"method","receiver":"this","name":"unlisten","string":"this.unlisten()"},"description":{"full":"<p>Unbinds all click and submit handlers that were attatched with listen.</p>\n\n<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default<br />behaviour restored.</p>","summary":"<p>Unbinds all click and submit handlers that were attatched with listen.</p>","body":"<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default<br />behaviour restored.</p>"},"full_description":"<p>Unbinds all click and submit handlers that were attatched with listen.</p>\n\n<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default behaviour restored.</p>","code":"this.unlisten = function () {\n    Davis.$(document).undelegate(this.settings.linkSelector, 'click', clickHandler)\n    Davis.$(document).undelegate(this.settings.formSelector, 'submit', submitHandler)\n  }\n}","params":[],"has_params":false,"tags":[{"type":"see","local":"Davis.App.settings","visibility":"Davis.App.settings"},{"type":"memberOf","parent":"listener"}],"module":false,"parent":"listener","related":{"name":"Davis.App.settings","href":"settings"},"has_related":true}]},{"id":"7-1342444637943","name":"event","signiture":"Davis.event()","type":"method","ctx":{"type":"method","receiver":"Davis","name":"event","string":"Davis.event()"},"description":{"full":"<p>A plugin that adds basic event capabilities to a Davis app, it is included by default.</p>","summary":"<p>A plugin that adds basic event capabilities to a Davis app, it is included by default.</p>","body":""},"full_description":"<p>A plugin that adds basic event capabilities to a Davis app, it is included by default.</p>","code":"Davis.event = function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"8-1342444637943","name":"bind","signiture":"this.bind()","type":"method","ctx":{"type":"method","receiver":"this","name":"bind","string":"this.bind()"},"description":{"full":"<p>Binds a callback to a named event.</p>\n\n<p>The following events are triggered internally by Davis and can be bound to</p>\n\n<ul>\n<li>start : Triggered when the application is started</li>\n<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>\n<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>\n<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>\n<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>\n<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>\n</ul>\n\n<p>Example</p>\n\n<pre><code>app.bind('runRoute', function () {\n  console.log('about to run a route')\n})\n</code></pre>","summary":"<p>Binds a callback to a named event.</p>","body":"<p>The following events are triggered internally by Davis and can be bound to</p>\n\n<ul>\n<li>start : Triggered when the application is started</li>\n<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>\n<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>\n<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>\n<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>\n<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>\n</ul>\n\n<p>Example</p>\n\n<pre><code>app.bind('runRoute', function () {\n  console.log('about to run a route')\n})\n</code></pre>"},"full_description":"<p>Binds a callback to a named event.</p>\n\n<p>The following events are triggered internally by Davis and can be bound to</p>\n\n<ul>\n<li>start : Triggered when the application is started</li>\n<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>\n<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>\n<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>\n<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>\n<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>\n</ul>\n\n<p>Example</p>\n\n<pre><code>app.bind('runRoute', function () {\n  console.log('about to run a route')\n})\n</code></pre>","code":"this.bind = function (event, fn) {\n    (callbacks[event] = callbacks[event] || []).push(fn);\n    return this;\n  };","params":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Function"],"name":"fn","description":"callback"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Function"],"name":"fn","description":"callback"},{"type":"memberOf","parent":"event"}],"module":false,"parent":"event","related":{"href":""},"has_related":true},{"id":"9-1342444637943","name":"trigger","signiture":"this.trigger()","type":"method","ctx":{"type":"method","receiver":"this","name":"trigger","string":"this.trigger()"},"description":{"full":"<p>Triggers an event with the given arguments.</p>","summary":"<p>Triggers an event with the given arguments.</p>","body":""},"full_description":"<p>Triggers an event with the given arguments.</p>","code":"this.trigger = function (event) {\n    var args = Davis.utils.toArray(arguments, 1),\n        handlers = callbacks[event];\n\n    if (!handlers) return this\n\n    for (var i = 0, len = handlers.length; i < len; ++i) {\n      handlers[i].apply(this, args)\n    }\n\n    return this;\n  };\n}","params":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Mixed"],"name":"...","description":""}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"event","description":"event name"},{"type":"param","types":["Mixed"],"name":"...","description":""},{"type":"memberOf","parent":"event"}],"module":false,"parent":"event","related":{"href":""},"has_related":true}]},{"id":"10-1342444637943","name":"logger","signiture":"Davis.logger()","type":"method","ctx":{"type":"method","receiver":"Davis","name":"logger","string":"Davis.logger()"},"description":{"full":"<p>A plugin for enhancing the standard logging available through the console object.<br />Automatically included in all Davis apps.</p>\n\n<p>Generates log messages of varying severity in the format</p>\n\n<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>","summary":"<p>A plugin for enhancing the standard logging available through the console object.<br />Automatically included in all Davis apps.</p>","body":"<p>Generates log messages of varying severity in the format</p>\n\n<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>"},"full_description":"<p>A plugin for enhancing the standard logging available through the console object. Automatically included in all Davis apps.</p>\n\n<p>Generates log messages of varying severity in the format</p>\n\n<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>","code":"Davis.logger = function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"11-1342444637943","name":"error","signiture":"error","type":"declaration","ctx":{"type":"declaration","name":"error","value":"logType('error')","string":"error"},"description":{"full":"<p>Prints an error message to the console if the console is available.</p>","summary":"<p>Prints an error message to the console if the console is available.</p>","body":""},"full_description":"<p>Prints an error message to the console if the console is available.</p>","code":"var error = logType('error')","params":[],"has_params":false,"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"module":false,"parent":"logger","related":{"href":""},"has_related":true},{"id":"12-1342444637943","name":"info","signiture":"info","type":"declaration","ctx":{"type":"declaration","name":"info","value":"logType('info')","string":"info"},"description":{"full":"<p>Prints an info message to the console if the console is available.</p>","summary":"<p>Prints an info message to the console if the console is available.</p>","body":""},"full_description":"<p>Prints an info message to the console if the console is available.</p>","code":"var info = logType('info')","params":[],"has_params":false,"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"module":false,"parent":"logger","related":{"href":""},"has_related":true},{"id":"13-1342444637943","name":"warn","signiture":"warn","type":"declaration","ctx":{"type":"declaration","name":"warn","value":"logType('warn')","string":"warn"},"description":{"full":"<p>Prints a warning message to the console if the console is available.</p>","summary":"<p>Prints a warning message to the console if the console is available.</p>","body":""},"full_description":"<p>Prints a warning message to the console if the console is available.</p>","code":"var warn = logType('warn')","params":[],"has_params":false,"tags":[{"type":"params"},{"type":"memberOf","parent":"logger"}],"module":false,"parent":"logger","related":{"href":""},"has_related":true}]},{"id":"14-1342444637943","name":"Route","signiture":"Route()","type":"function","ctx":{"type":"function","name":"Route","string":"Route()"},"description":{"full":"<p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path<br />and a callback function.  When a link or a form that Davis has bound to are clicked or submitted<br />a request is pushed on the history stack and a route that matches the path and method of the<br />generated request is run.</p>\n\n<p>The path for the route can consist of placeholders for attributes, these will then be available<br />on the request.  Simple variables should be prefixed with a colan, and for splat style params use<br />an asterisk.</p>\n\n<p>Inside the callback function 'this' is bound to the request.</p>\n\n<h2>Example</h2>\n\n<pre><code>var route = new Davis.Route ('get', '/foo/:id', function (req) {\n  var id = req.params['id']\n  // do something interesting!\n})\n\nvar route = new Davis.Route ('get', '/foo/*splat', function (req) {\n  var id = req.params['splat']\n  // splat will contain everything after the /foo/ in the path.\n})\n</code></pre>\n\n<p>You can include any number of route level 'middleware' when defining routes.  These middlewares are<br />run in order and need to explicitly call the next handler in the stack.  Using route middleware allows<br />you to share common logic between routes and is also a good place to load any data or do any async calls<br />keeping your main handler simple and focused.</p>\n\n<h2>Example</h2>\n\n<pre><code>var loadUser = function (req, next) {\n  $.get('/users/current', function (user) {\n    req.user = user\n    next(req)\n  })\n}\n\nvar route = new Davis.Route ('get', '/foo/:id', loadUser, function (req) {\n  renderUser(req.user)\n})\n</code></pre>","summary":"<p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path<br />and a callback function.  When a link or a form that Davis has bound to are clicked or submitted<br />a request is pushed on the history stack and a route that matches the path and method of the<br />generated request is run.</p>","body":"<p>The path for the route can consist of placeholders for attributes, these will then be available<br />on the request.  Simple variables should be prefixed with a colan, and for splat style params use<br />an asterisk.</p>\n\n<p>Inside the callback function 'this' is bound to the request.</p>\n\n<h2>Example</h2>\n\n<pre><code>var route = new Davis.Route ('get', '/foo/:id', function (req) {\n  var id = req.params['id']\n  // do something interesting!\n})\n\nvar route = new Davis.Route ('get', '/foo/*splat', function (req) {\n  var id = req.params['splat']\n  // splat will contain everything after the /foo/ in the path.\n})\n</code></pre>\n\n<p>You can include any number of route level 'middleware' when defining routes.  These middlewares are<br />run in order and need to explicitly call the next handler in the stack.  Using route middleware allows<br />you to share common logic between routes and is also a good place to load any data or do any async calls<br />keeping your main handler simple and focused.</p>\n\n<h2>Example</h2>\n\n<pre><code>var loadUser = function (req, next) {\n  $.get('/users/current', function (user) {\n    req.user = user\n    next(req)\n  })\n}\n\nvar route = new Davis.Route ('get', '/foo/:id', loadUser, function (req) {\n  renderUser(req.user)\n})\n</code></pre>"},"full_description":"<p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path and a callback function.  When a link or a form that Davis has bound to are clicked or submitted a request is pushed on the history stack and a route that matches the path and method of the generated request is run.</p>\n\n<p>The path for the route can consist of placeholders for attributes, these will then be available on the request.  Simple variables should be prefixed with a colan, and for splat style params use an asterisk.</p>\n\n<p>Inside the callback function 'this' is bound to the request.</p>\n\n<h2>Example</h2>\n\n<pre><code>var route = new Davis.Route ('get', '/foo/:id', function (req) {\n  var id = req.params['id']\n  // do something interesting!\n})\n\nvar route = new Davis.Route ('get', '/foo/*splat', function (req) {\n  var id = req.params['splat']\n  // splat will contain everything after the /foo/ in the path.\n})\n</code></pre>\n\n<p>You can include any number of route level 'middleware' when defining routes.  These middlewares are run in order and need to explicitly call the next handler in the stack.  Using route middleware allows you to share common logic between routes and is also a good place to load any data or do any async calls keeping your main handler simple and focused.</p>\n\n<h2>Example</h2>\n\n<pre><code>var loadUser = function (req, next) {\n  $.get('/users/current', function (user) {\n    req.user = user\n    next(req)\n  })\n}\n\nvar route = new Davis.Route ('get', '/foo/:id', loadUser, function (req) {\n  renderUser(req.user)\n})\n</code></pre>","code":"var Route = function (method, path, handlers) {\n    var convertPathToRegExp = function () {\n      if (!(path instanceof RegExp)) {\n        var str = path\n          .replace(pathNameRegex, pathNameReplacement)\n          .replace(splatNameRegex, splatNameReplacement);\n\n        // Most browsers will reset this to zero after a replace call.  IE will\n        // set it to the index of the last matched character.\n        path.lastIndex = 0;\n\n        return new RegExp(\"^\" + str + \"$\", \"gi\");\n      } else {\n        return path;\n      };\n    };\n\n    var convertMethodToRegExp = function () {\n      if (!(method instanceof RegExp)) {\n        return new RegExp(\"^\" + method + \"$\", \"i\");\n      } else {\n        return method\n      };\n    }\n\n    var capturePathParamNames = function () {\n      var names = [], a;\n      while ((a = nameRegex.exec(path))) names.push(a[1]);\n      return names;\n    };\n\n    this.paramNames = capturePathParamNames();\n    this.path = convertPathToRegExp();\n    this.method = convertMethodToRegExp();\n\n    if (typeof handlers === 'function') {\n      this.handlers = [handlers]\n    } else {\n      this.handlers = handlers;\n    }\n  }","params":[{"type":"param","types":["String"],"name":"method","description":"This should be one of either 'get', 'post', 'put', 'delete', 'before', 'after' or 'state'"},{"type":"param","types":["String"],"name":"path","description":"This string can contain place holders for variables, e.g. '/user/:id' or '/user/*splat'"},{"type":"param","types":["Function"],"name":"callback","description":"One or more callbacks that will be called in order when a request matching both the path and method is triggered."}],"has_params":true,"tags":[{"type":"constructor"},{"type":"param","types":["String"],"name":"method","description":"This should be one of either 'get', 'post', 'put', 'delete', 'before', 'after' or 'state'"},{"type":"param","types":["String"],"name":"path","description":"This string can contain place holders for variables, e.g. '/user/:id' or '/user/*splat'"},{"type":"param","types":["Function"],"name":"callback","description":"One or more callbacks that will be called in order when a request matching both the path and method is triggered."}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"15-1342444637943","name":"match","signiture":"Route.prototype.match()","type":"method","ctx":{"type":"method","constructor":"Route","name":"match","string":"Route.prototype.match()"},"description":{"full":"<p>Tests whether or not a route matches a particular request.</p>\n\n<h2>Example</h2>\n\n<pre><code>route.match('get', '/foo/12')\n</code></pre>","summary":"<p>Tests whether or not a route matches a particular request.</p>","body":"<h2>Example</h2>\n\n<pre><code>route.match('get', '/foo/12')\n</code></pre>"},"full_description":"<p>Tests whether or not a route matches a particular request.</p>\n\n<h2>Example</h2>\n\n<pre><code>route.match('get', '/foo/12')\n</code></pre>","code":"Route.prototype.match = function (method, path) {\n    this.reset();\n    return (this.method.test(method)) && (this.path.test(path))\n  }","params":[{"type":"param","types":["String"],"name":"method","description":"the method to match against"},{"type":"param","types":["String"],"name":"path","description":"the path to match against"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"method","description":"the method to match against"},{"type":"param","types":["String"],"name":"path","description":"the path to match against"},{"type":"returns"}],"module":false,"parent":"Route","related":{"href":""},"has_related":true},{"id":"16-1342444637943","name":"reset","signiture":"Route.prototype.reset()","type":"method","ctx":{"type":"method","constructor":"Route","name":"reset","string":"Route.prototype.reset()"},"description":{"full":"<p>Resets the RegExps for method and path</p>","summary":"<p>Resets the RegExps for method and path</p>","body":""},"full_description":"<p>Resets the RegExps for method and path</p>","code":"Route.prototype.reset = function () {\n    this.method.lastIndex = 0;\n    this.path.lastIndex = 0;\n  }","params":[],"has_params":false,"tags":[],"module":false,"parent":"Route","has_related":false},{"id":"17-1342444637943","name":"run","signiture":"Route.prototype.run()","type":"method","ctx":{"type":"method","constructor":"Route","name":"run","string":"Route.prototype.run()"},"description":{"full":"<p>Runs the callback associated with a particular route against the passed request.</p>\n\n<p>Any named params in the request path are extracted, as per the routes path, and<br />added onto the requests params object.</p>\n\n<h2>Example</h2>\n\n<pre><code>route.run(request)\n</code></pre>","summary":"<p>Runs the callback associated with a particular route against the passed request.</p>","body":"<p>Any named params in the request path are extracted, as per the routes path, and<br />added onto the requests params object.</p>\n\n<h2>Example</h2>\n\n<pre><code>route.run(request)\n</code></pre>"},"full_description":"<p>Runs the callback associated with a particular route against the passed request.</p>\n\n<p>Any named params in the request path are extracted, as per the routes path, and added onto the requests params object.</p>\n\n<h2>Example</h2>\n\n<pre><code>route.run(request)\n</code></pre>","code":"Route.prototype.run = function (request) {\n    this.reset();\n    var matches = this.path.exec(request.path);\n    if (matches) {\n      matches.shift();\n      for (var i=0; i < matches.length; i++) {\n        request.params[this.paramNames[i]] = matches[i];\n      };\n    };\n\n    var handlers = Davis.utils.map(this.handlers, function (handler, i) {\n      return function (req) {\n        return handler.call(req, req, handlers[i+1])\n      }\n    })\n\n    return handlers[0](request)\n  }","params":[],"has_params":false,"tags":[{"type":"params"},{"type":"returns"}],"module":false,"parent":"Route","related":{"href":""},"has_related":true},{"id":"18-1342444637943","name":"toString","signiture":"Route.prototype.toString()","type":"method","ctx":{"type":"method","constructor":"Route","name":"toString","string":"Route.prototype.toString()"},"description":{"full":"<p>Converts the route to a string representation of itself by combining the method and path<br />attributes.</p>","summary":"<p>Converts the route to a string representation of itself by combining the method and path<br />attributes.</p>","body":""},"full_description":"<p>Converts the route to a string representation of itself by combining the method and path attributes.</p>","code":"Route.prototype.toString = function () {\n    return [this.method, this.path].join(' ');\n  }","params":[],"has_params":false,"tags":[{"type":"returns"}],"module":false,"parent":"Route","related":{"href":""},"has_related":true}]},{"id":"19-1342444637943","name":"router","signiture":"Davis.router()","type":"method","ctx":{"type":"method","receiver":"Davis","name":"router","string":"Davis.router()"},"description":{"full":"<p>A decorator that adds convinience methods to a Davis.App for easily creating instances<br />of Davis.Route and looking up routes for a particular request.</p>\n\n<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes<br />with the corresponding method.  This allows simple REST styled routing for a client side<br />JavaScript application.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.get('/foo/:id', function (req) {\n  // get the foo with id = req.params['id']\n})\n\napp.post('/foo', function (req) {\n  // create a new instance of foo with req.params\n})\n\napp.put('/foo/:id', function (req) {\n  // update the instance of foo with id = req.params['id']\n})\n\napp.del('/foo/:id', function (req) {\n  // delete the instance of foo with id = req.params['id']\n})\n</code></pre>\n\n<p>As well as providing convinience methods for creating instances of Davis.Routes the router<br />also provides methods for creating special instances of routes called filters.  Before filters<br />run before any matching route is run, and after filters run after any matched route has run.<br />A before filter can return false to halt the running of any matched routes or other before filters.</p>\n\n<p>A filter can take an optional path to match on, or without a path will match every request.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.before('/foo/:id', function (req) {\n  // will only run before request matching '/foo/:id'\n})\n\napp.before(function (req) {\n  // will run before all routes\n})\n\napp.after('/foo/:id', function (req) {\n  // will only run after routes matching '/foo/:id'\n})\n\napp.after(function (req) {\n  // will run after all routes\n})\n</code></pre>\n\n<p>Another special kind of route, called state routes, are also generated using the router.  State routes<br />are for requests that will not change the current page location.  Instead the page location will remain<br />the same but the current state of the page has changed.  This allows for states which the server will not<br />be expected to know about and support.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>\n\n<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>\n\n<p>For convinience routes can be defined within a common base scope, this is useful for keeping your route<br />definitions simpler and DRYer.  A scope can either cover the whole app, or just a subset of the routes.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.scope('/foo', function () {\n  this.get('/:id', function () {\n    // will run for routes that match '/foo/:id'\n  })\n})\n</code></pre>","summary":"<p>A decorator that adds convinience methods to a Davis.App for easily creating instances<br />of Davis.Route and looking up routes for a particular request.</p>","body":"<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes<br />with the corresponding method.  This allows simple REST styled routing for a client side<br />JavaScript application.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.get('/foo/:id', function (req) {\n  // get the foo with id = req.params['id']\n})\n\napp.post('/foo', function (req) {\n  // create a new instance of foo with req.params\n})\n\napp.put('/foo/:id', function (req) {\n  // update the instance of foo with id = req.params['id']\n})\n\napp.del('/foo/:id', function (req) {\n  // delete the instance of foo with id = req.params['id']\n})\n</code></pre>\n\n<p>As well as providing convinience methods for creating instances of Davis.Routes the router<br />also provides methods for creating special instances of routes called filters.  Before filters<br />run before any matching route is run, and after filters run after any matched route has run.<br />A before filter can return false to halt the running of any matched routes or other before filters.</p>\n\n<p>A filter can take an optional path to match on, or without a path will match every request.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.before('/foo/:id', function (req) {\n  // will only run before request matching '/foo/:id'\n})\n\napp.before(function (req) {\n  // will run before all routes\n})\n\napp.after('/foo/:id', function (req) {\n  // will only run after routes matching '/foo/:id'\n})\n\napp.after(function (req) {\n  // will run after all routes\n})\n</code></pre>\n\n<p>Another special kind of route, called state routes, are also generated using the router.  State routes<br />are for requests that will not change the current page location.  Instead the page location will remain<br />the same but the current state of the page has changed.  This allows for states which the server will not<br />be expected to know about and support.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>\n\n<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>\n\n<p>For convinience routes can be defined within a common base scope, this is useful for keeping your route<br />definitions simpler and DRYer.  A scope can either cover the whole app, or just a subset of the routes.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.scope('/foo', function () {\n  this.get('/:id', function () {\n    // will run for routes that match '/foo/:id'\n  })\n})\n</code></pre>"},"full_description":"<p>A decorator that adds convinience methods to a Davis.App for easily creating instances of Davis.Route and looking up routes for a particular request.</p>\n\n<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes with the corresponding method.  This allows simple REST styled routing for a client side JavaScript application.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.get('/foo/:id', function (req) {\n  // get the foo with id = req.params['id']\n})\n\napp.post('/foo', function (req) {\n  // create a new instance of foo with req.params\n})\n\napp.put('/foo/:id', function (req) {\n  // update the instance of foo with id = req.params['id']\n})\n\napp.del('/foo/:id', function (req) {\n  // delete the instance of foo with id = req.params['id']\n})\n</code></pre>\n\n<p>As well as providing convinience methods for creating instances of Davis.Routes the router also provides methods for creating special instances of routes called filters.  Before filters run before any matching route is run, and after filters run after any matched route has run. A before filter can return false to halt the running of any matched routes or other before filters.</p>\n\n<p>A filter can take an optional path to match on, or without a path will match every request.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.before('/foo/:id', function (req) {\n  // will only run before request matching '/foo/:id'\n})\n\napp.before(function (req) {\n  // will run before all routes\n})\n\napp.after('/foo/:id', function (req) {\n  // will only run after routes matching '/foo/:id'\n})\n\napp.after(function (req) {\n  // will run after all routes\n})\n</code></pre>\n\n<p>Another special kind of route, called state routes, are also generated using the router.  State routes are for requests that will not change the current page location.  Instead the page location will remain the same but the current state of the page has changed.  This allows for states which the server will not be expected to know about and support.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>\n\n<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>\n\n<p>For convinience routes can be defined within a common base scope, this is useful for keeping your route definitions simpler and DRYer.  A scope can either cover the whole app, or just a subset of the routes.</p>\n\n<h3>Example</h3>\n\n<pre><code>app.scope('/foo', function () {\n  this.get('/:id', function () {\n    // will run for routes that match '/foo/:id'\n  })\n})\n</code></pre>","code":"Davis.router = function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"20-1342444637943","name":"route","signiture":"this.route()","type":"method","ctx":{"type":"method","receiver":"this","name":"route","string":"this.route()"},"description":{"full":"<p>Low level method for adding routes to your application.</p>\n\n<p>If called with just a method will return a partially applied function that can create routes with<br />that method.  This is used internally to provide shortcuts for get, post, put, delete and state<br />routes.</p>\n\n<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending<br />Davis to work with other kinds of requests.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.route('get', '/foo', function (req) {\n  // will run when a get request is made to '/foo'\n})\n\napp.patch = app.route('patch') // will return a function that can be used to handle requests with method of patch.\napp.patch('/bar', function (req) {\n  // will run when a patch request is made to '/bar'\n})\n</code></pre>","summary":"<p>Low level method for adding routes to your application.</p>","body":"<p>If called with just a method will return a partially applied function that can create routes with<br />that method.  This is used internally to provide shortcuts for get, post, put, delete and state<br />routes.</p>\n\n<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending<br />Davis to work with other kinds of requests.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.route('get', '/foo', function (req) {\n  // will run when a get request is made to '/foo'\n})\n\napp.patch = app.route('patch') // will return a function that can be used to handle requests with method of patch.\napp.patch('/bar', function (req) {\n  // will run when a patch request is made to '/bar'\n})\n</code></pre>"},"full_description":"<p>Low level method for adding routes to your application.</p>\n\n<p>If called with just a method will return a partially applied function that can create routes with that method.  This is used internally to provide shortcuts for get, post, put, delete and state routes.</p>\n\n<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending Davis to work with other kinds of requests.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.route('get', '/foo', function (req) {\n  // will run when a get request is made to '/foo'\n})\n\napp.patch = app.route('patch') // will return a function that can be used to handle requests with method of patch.\napp.patch('/bar', function (req) {\n  // will run when a patch request is made to '/bar'\n})\n</code></pre>","code":"this.route = function (method, path) {\n    var createRoute = function (path) {\n      var handlers = Davis.utils.toArray(arguments, 1),\n          scope = scopePaths.join(''),\n          route = new Davis.Route (method, scope + path, handlers)\n\n      routeCollection.push(route)\n      return route\n    }\n\n    return (arguments.length == 1) ? createRoute : createRoute.apply(this, Davis.utils.toArray(arguments, 1))\n  }","params":[{"type":"param","types":["String"],"name":"method","description":"The method for this route."},{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"method","description":"The method for this route."},{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"21-1342444637943","name":"get","signiture":"this.get","type":"property","ctx":{"type":"property","receiver":"this","name":"get","value":"this.route('get')","string":"this.get"},"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>","code":"this.get  = this.route('get')","params":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"22-1342444637943","name":"post","signiture":"this.post","type":"property","ctx":{"type":"property","receiver":"this","name":"post","value":"this.route('post')","string":"this.post"},"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>","code":"this.post = this.route('post')","params":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"23-1342444637943","name":"put","signiture":"this.put","type":"property","ctx":{"type":"property","receiver":"this","name":"put","value":"this.route('put')","string":"this.put"},"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>","code":"this.put  = this.route('put')","params":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"24-1342444637943","name":"del","signiture":"this.del","type":"property","ctx":{"type":"property","receiver":"this","name":"del","value":"this.route('delete')","string":"this.del"},"description":{"full":"<p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>\n\n<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>","summary":"<p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>","body":"<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>"},"full_description":"<p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>\n\n<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>","code":"this.del  = this.route('delete')","params":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route."},{"type":"returns"},{"type":"see","local":"Davis.router.route","visibility":"Davis.router.route"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"25-1342444637943","name":"state","signiture":"this.state","type":"property","ctx":{"type":"property","receiver":"this","name":"state","value":"this.route('state')","string":"this.state"},"description":{"full":"<p>Adds a state route into the apps route collection.</p>\n\n<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they<br />are triggered manually by calling <code>trans</code>.</p>\n\n<p>Routes added using the state method act in the same way as other routes except that they generate<br />a route that is listening for requests that will not change the page location.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>","summary":"<p>Adds a state route into the apps route collection.</p>","body":"<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they<br />are triggered manually by calling <code>trans</code>.</p>\n\n<p>Routes added using the state method act in the same way as other routes except that they generate<br />a route that is listening for requests that will not change the page location.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>"},"full_description":"<p>Adds a state route into the apps route collection.</p>\n\n<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they are triggered manually by calling <code>trans</code>.</p>\n\n<p>Routes added using the state method act in the same way as other routes except that they generate a route that is listening for requests that will not change the page location.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.state('/foo/:id', function (req) {\n  // will run when the app transitions into the '/foo/:id' state.\n})\n</code></pre>","code":"this.state = this.route('state');","params":[{"type":"param","types":["String"],"name":"path","description":"The path for this route, this will never be seen in the url bar."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path for this route, this will never be seen in the url bar."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this route, will be called with the request that triggered the route"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"26-1342444637943","name":"scope","signiture":"this.scope()","type":"method","ctx":{"type":"method","receiver":"this","name":"scope","string":"this.scope()"},"description":{"full":"<p>Modifies the scope of the router.</p>\n\n<p>If you have many routes that share a common path prefix you can use scope to reduce repeating<br />that path prefix.</p>\n\n<p>You can use <code>scope</code> in two ways, firstly you can set the scope for the whole app by calling scope<br />before defining routes.  You can also provide a function to the scope method, and the scope will<br />only apply to those routes defined within this function. It is  also possible to nest scopes within<br />other scopes.</p>\n\n<p>Example</p>\n\n<pre><code>// using scope with a function\napp.scope('/foo', function () {\n  this.get('/bar', function (req) {\n    // this route will have a path of '/foo/bar'\n  })\n})\n\n// setting a global scope for the rest of the application\napp.scope('/bar')\n\n// using scope with a function\napp.scope('/foo', function () {\n  this.scope('/bar', function () {\n    this.get('/baz', function (req) {\n      // this route will have a path of '/foo/bar/baz'\n    })\n  })\n})\n</code></pre>","summary":"<p>Modifies the scope of the router.</p>","body":"<p>If you have many routes that share a common path prefix you can use scope to reduce repeating<br />that path prefix.</p>\n\n<p>You can use <code>scope</code> in two ways, firstly you can set the scope for the whole app by calling scope<br />before defining routes.  You can also provide a function to the scope method, and the scope will<br />only apply to those routes defined within this function. It is  also possible to nest scopes within<br />other scopes.</p>\n\n<p>Example</p>\n\n<pre><code>// using scope with a function\napp.scope('/foo', function () {\n  this.get('/bar', function (req) {\n    // this route will have a path of '/foo/bar'\n  })\n})\n\n// setting a global scope for the rest of the application\napp.scope('/bar')\n\n// using scope with a function\napp.scope('/foo', function () {\n  this.scope('/bar', function () {\n    this.get('/baz', function (req) {\n      // this route will have a path of '/foo/bar/baz'\n    })\n  })\n})\n</code></pre>"},"full_description":"<p>Modifies the scope of the router.</p>\n\n<p>If you have many routes that share a common path prefix you can use scope to reduce repeating that path prefix.</p>\n\n<p>You can use <code>scope</code> in two ways, firstly you can set the scope for the whole app by calling scope before defining routes.  You can also provide a function to the scope method, and the scope will only apply to those routes defined within this function. It is  also possible to nest scopes within other scopes.</p>\n\n<p>Example</p>\n\n<pre><code>// using scope with a function\napp.scope('/foo', function () {\n  this.get('/bar', function (req) {\n    // this route will have a path of '/foo/bar'\n  })\n})\n\n// setting a global scope for the rest of the application\napp.scope('/bar')\n\n// using scope with a function\napp.scope('/foo', function () {\n  this.scope('/bar', function () {\n    this.get('/baz', function (req) {\n      // this route will have a path of '/foo/bar/baz'\n    })\n  })\n})\n</code></pre>","code":"this.scope = function (path, fn) {\n    scopePaths.push(path)\n    if (arguments.length == 1) return\n\n    fn.call(this, this)\n    scopePaths.pop()\n  }","params":[{"type":"param","types":["String"],"name":"path","description":"The prefix to use as the scope"},{"type":"param","types":["Function"],"name":"fn","description":"A function that will be executed with the router as its context and the path"}],"has_params":true,"tags":[{"type":"memberOf","parent":"router"},{"type":"param","types":["String"],"name":"path","description":"The prefix to use as the scope"},{"type":"param","types":["Function"],"name":"fn","description":"A function that will be executed with the router as its context and the path"},{"type":"as"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"27-1342444637943","name":"trans","signiture":"this.trans()","type":"method","ctx":{"type":"method","receiver":"this","name":"trans","string":"this.trans()"},"description":{"full":"<p>Transitions the app into the state identified by the passed path parameter.</p>\n\n<p>This allows the app to enter states without changing the page path through a link click or form submit. <br />If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>\n\n<p>This method generates a request with a method of 'state', in all other ways this request is identical<br />to those that are generated when clicking links etc.</p>\n\n<p>States transitioned to using this method will not be able to be revisited directly with a page load as<br />there is no url that represents the state.</p>\n\n<p>An optional second parameter can be passed which will be available to any handlers in the requests<br />params object.</p>\n\n<p>Example</p>\n\n<pre><code>app.trans('/foo/1')\n\napp.trans('/foo/1', {\n  \"bar\": \"baz\"\n})\n</code></pre>","summary":"<p>Transitions the app into the state identified by the passed path parameter.</p>","body":"<p>This allows the app to enter states without changing the page path through a link click or form submit. <br />If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>\n\n<p>This method generates a request with a method of 'state', in all other ways this request is identical<br />to those that are generated when clicking links etc.</p>\n\n<p>States transitioned to using this method will not be able to be revisited directly with a page load as<br />there is no url that represents the state.</p>\n\n<p>An optional second parameter can be passed which will be available to any handlers in the requests<br />params object.</p>\n\n<p>Example</p>\n\n<pre><code>app.trans('/foo/1')\n\napp.trans('/foo/1', {\n  \"bar\": \"baz\"\n})\n</code></pre>"},"full_description":"<p>Transitions the app into the state identified by the passed path parameter.</p>\n\n<p>This allows the app to enter states without changing the page path through a link click or form submit.  If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>\n\n<p>This method generates a request with a method of 'state', in all other ways this request is identical to those that are generated when clicking links etc.</p>\n\n<p>States transitioned to using this method will not be able to be revisited directly with a page load as there is no url that represents the state.</p>\n\n<p>An optional second parameter can be passed which will be available to any handlers in the requests params object.</p>\n\n<p>Example</p>\n\n<pre><code>app.trans('/foo/1')\n\napp.trans('/foo/1', {\n  \"bar\": \"baz\"\n})\n</code></pre>","code":"this.trans = function (path, data) {\n    if (data) {\n      var fullPath = [path, decodeURIComponent(Davis.$.param(data))].join('?')\n    } else {\n      var fullPath = path\n    };\n\n    var req = new Davis.Request({\n      method: 'state',\n      fullPath: fullPath,\n      title: ''\n    })\n\n    Davis.location.assign(req)\n  }","params":[{"type":"param","types":["String"],"name":"path","description":"The path that represents this state. This will not be seen in the url bar."},{"type":"param","types":["Object"],"name":"data","description":"Any additional data that should be sent with the request as params."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path that represents this state. This will not be seen in the url bar."},{"type":"param","types":["Object"],"name":"data","description":"Any additional data that should be sent with the request as params."},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"28-1342444637943","name":"before","signiture":"this.before","type":"property","ctx":{"type":"property","receiver":"this","name":"before","value":"this.filter('before')","string":"this.before"},"description":{"full":"<p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>","summary":"<p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>","code":"this.before = this.filter('before')","params":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"29-1342444637943","name":"after","signiture":"this.after","type":"property","ctx":{"type":"property","receiver":"this","name":"after","value":"this.filter('after')","string":"this.after"},"description":{"full":"<p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>","summary":"<p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>","code":"this.after = this.filter('after')","params":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"30-1342444637943","name":"lookupBeforeFilter","signiture":"this.lookupBeforeFilter","type":"property","ctx":{"type":"property","receiver":"this","name":"lookupBeforeFilter","value":"this.lookupFilter('before')","string":"this.lookupBeforeFilter"},"description":{"full":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>","summary":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>","code":"this.lookupBeforeFilter = this.lookupFilter('before')","params":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"31-1342444637943","name":"lookupAfterFilter","signiture":"this.lookupAfterFilter","type":"property","ctx":{"type":"property","receiver":"this","name":"lookupAfterFilter","value":"this.lookupFilter('after')","string":"this.lookupAfterFilter"},"description":{"full":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>","summary":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>","body":""},"full_description":"<p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>","code":"this.lookupAfterFilter  = this.lookupFilter('after')","params":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The optionl path for this filter."},{"type":"param","types":["Function"],"name":"handler","description":"The handler for this filter, will be called with the request that triggered the route."},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true},{"id":"32-1342444637943","name":"lookupRoute","signiture":"this.lookupRoute()","type":"method","ctx":{"type":"method","receiver":"this","name":"lookupRoute","string":"this.lookupRoute()"},"description":{"full":"<p>Looks for the first route that matches the method and path from a request.<br />Will only find and return the first matched route.</p>","summary":"<p>Looks for the first route that matches the method and path from a request.<br />Will only find and return the first matched route.</p>","body":""},"full_description":"<p>Looks for the first route that matches the method and path from a request. Will only find and return the first matched route.</p>","code":"this.lookupRoute = function (method, path) {\n    return Davis.utils.filter(routeCollection, function (route) {\n      return route.match(method, path)\n    })[0];\n  };\n}","params":[{"type":"param","types":["String"],"name":"method","description":"the method to use when looking up a route"},{"type":"param","types":["String"],"name":"path","description":"the path to use when looking up a route"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"method","description":"the method to use when looking up a route"},{"type":"param","types":["String"],"name":"path","description":"the path to use when looking up a route"},{"type":"returns"},{"type":"memberOf","parent":"router"}],"module":false,"parent":"router","related":{"href":""},"has_related":true}]},{"id":"33-1342444637943","name":"history","signiture":"Davis.history","type":"property","ctx":{"type":"property","receiver":"Davis","name":"history","value":"(function () {","string":"Davis.history"},"description":{"full":"<p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>\n\n<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes<br />both of these events into an onChange event.</p>","summary":"<p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>","body":"<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes<br />both of these events into an onChange event.</p>"},"full_description":"<p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>\n\n<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes both of these events into an onChange event.</p>","code":"Davis.history = (function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"34-1342444637943","name":"onChange","signiture":"onChange()","type":"function","ctx":{"type":"function","name":"onChange","string":"onChange()"},"description":{"full":"<p>Bind to the history on change event.</p>\n\n<p>This is not a native event but is fired any time a new state is pushed onto the history stack,<br />the current history is replaced or a state is popped off the history stack.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>","summary":"<p>Bind to the history on change event.</p>","body":"<p>This is not a native event but is fired any time a new state is pushed onto the history stack,<br />the current history is replaced or a state is popped off the history stack.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>"},"full_description":"<p>Bind to the history on change event.</p>\n\n<p>This is not a native event but is fired any time a new state is pushed onto the history stack, the current history is replaced or a state is popped off the history stack. The handler function will be called with a request param which is an instance of Davis.Request.</p>","code":"function onChange(handler) {\n    onPushState(handler);\n    onPopState(wrapped(handler));\n  };","params":[{"type":"param","types":["Function"],"name":"handler","description":"a function that will be called on push and pop state."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"handler","description":"a function that will be called on push and pop state."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"history"}],"module":false,"parent":"history","related":{"href":""},"has_related":true},{"id":"35-1342444637943","name":"assign","signiture":"assign","type":"declaration","ctx":{"type":"declaration","name":"assign","value":"changeStateWith('pushState')","string":"assign"},"description":{"full":"<p>Pushes a request onto the history stack.</p>\n\n<p>This is used internally by Davis to push a new request<br />resulting from either a form submit or a link click onto the history stack, it will also trigger<br />the onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title<br />and a path property will also be accepted.</p>","summary":"<p>Pushes a request onto the history stack.</p>","body":"<p>This is used internally by Davis to push a new request<br />resulting from either a form submit or a link click onto the history stack, it will also trigger<br />the onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title<br />and a path property will also be accepted.</p>"},"full_description":"<p>Pushes a request onto the history stack.</p>\n\n<p>This is used internally by Davis to push a new request resulting from either a form submit or a link click onto the history stack, it will also trigger the onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title and a path property will also be accepted.</p>","code":"var assign = changeStateWith('pushState')","params":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to be assinged as the current location."}],"has_params":true,"tags":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to be assinged as the current location."},{"type":"memberOf","parent":"history"}],"module":false,"parent":"history","related":{"href":""},"has_related":true},{"id":"36-1342444637943","name":"replace","signiture":"replace","type":"declaration","ctx":{"type":"declaration","name":"replace","value":"changeStateWith('replaceState')","string":"replace"},"description":{"full":"<p>Replace the current state on the history stack.</p>\n\n<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title<br />and a path property will also be accepted.</p>","summary":"<p>Replace the current state on the history stack.</p>","body":"<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title<br />and a path property will also be accepted.</p>"},"full_description":"<p>Replace the current state on the history stack.</p>\n\n<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>\n\n<p>An instance of Davis.Request is expected to be passed, however any object that has a title and a path property will also be accepted.</p>","code":"var replace = changeStateWith('replaceState')","params":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to replace the current location with."}],"has_params":true,"tags":[{"type":"param","types":["Davis.Request"],"name":"request","description":"the location to replace the current location with."},{"type":"memberOf","parent":"history"}],"module":false,"parent":"history","related":{"href":""},"has_related":true},{"id":"37-1342444637943","name":"current","signiture":"current()","type":"function","ctx":{"type":"function","name":"current","string":"current()"},"description":{"full":"<p>Returns the current location for the application.</p>\n\n<p>Davis.location delegates to this method for getting the apps current location.</p>","summary":"<p>Returns the current location for the application.</p>","body":"<p>Davis.location delegates to this method for getting the apps current location.</p>"},"full_description":"<p>Returns the current location for the application.</p>\n\n<p>Davis.location delegates to this method for getting the apps current location.</p>","code":"function current() {\n    return window.location.pathname + (window.location.search ? window.location.search : '')\n  }","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"history"}],"module":false,"parent":"history","related":{"href":""},"has_related":true}]},{"id":"38-1342444637943","name":"location","signiture":"Davis.location","type":"property","ctx":{"type":"property","receiver":"Davis","name":"location","value":"(function () {","string":"Davis.location"},"description":{"full":"<p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of<br />what is being used for the apps routing away from the rest of the library.  This allows any kind of routing<br />To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>\n\n<p>A routing module must respond to the following methods</p>\n\n<ul>\n<li><strong>current</strong> : Should return the current location for the app</li>\n<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>\n<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>\n<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>\n</ul>","summary":"<p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of<br />what is being used for the apps routing away from the rest of the library.  This allows any kind of routing<br />To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>","body":"<p>A routing module must respond to the following methods</p>\n\n<ul>\n<li><strong>current</strong> : Should return the current location for the app</li>\n<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>\n<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>\n<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>\n</ul>"},"full_description":"<p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of what is being used for the apps routing away from the rest of the library.  This allows any kind of routing To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>\n\n<p>A routing module must respond to the following methods</p>\n\n<ul>\n<li><strong>current</strong> : Should return the current location for the app</li>\n<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>\n<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>\n<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>\n</ul>","code":"Davis.location = (function () {","params":[],"has_params":false,"tags":[{"type":"module"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"39-1342444637943","name":"setLocationDelegate","signiture":"setLocationDelegate()","type":"function","ctx":{"type":"function","name":"setLocationDelegate","string":"setLocationDelegate()"},"description":{"full":"<p>Sets the current location delegate.</p>\n\n<p>The passed delegate will be used for all Davis apps.  The delegate<br />must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>","summary":"<p>Sets the current location delegate.</p>","body":"<p>The passed delegate will be used for all Davis apps.  The delegate<br />must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>"},"full_description":"<p>Sets the current location delegate.</p>\n\n<p>The passed delegate will be used for all Davis apps.  The delegate must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>","code":"function setLocationDelegate(delegate) {\n    locationDelegate = delegate\n  }","params":[{"type":"param","types":["Object"],"name":"the","description":"location delegate to use."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"the","description":"location delegate to use."},{"type":"memberOf","parent":"location"}],"module":false,"parent":"location","related":{"href":""},"has_related":true},{"id":"40-1342444637943","name":"current","signiture":"current()","type":"function","ctx":{"type":"function","name":"current","string":"current()"},"description":{"full":"<p>Delegates to the locationDelegate.current method.</p>\n\n<p>This should return the current location of the app.</p>","summary":"<p>Delegates to the locationDelegate.current method.</p>","body":"<p>This should return the current location of the app.</p>"},"full_description":"<p>Delegates to the locationDelegate.current method.</p>\n\n<p>This should return the current location of the app.</p>","code":"function current() {\n    return locationDelegate.current()\n  }","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"location"}],"module":false,"parent":"location","related":{"href":""},"has_related":true},{"id":"41-1342444637943","name":"assign","signiture":"assign","type":"declaration","ctx":{"type":"declaration","name":"assign","value":"sendLocationDelegate('assign')","string":"assign"},"description":{"full":"<p>Delegates to the locationDelegate.assign method.</p>\n\n<p>This should set the current location for the app to that of the passed request object.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>","summary":"<p>Delegates to the locationDelegate.assign method.</p>","body":"<p>This should set the current location for the app to that of the passed request object.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>"},"full_description":"<p>Delegates to the locationDelegate.assign method.</p>\n\n<p>This should set the current location for the app to that of the passed request object.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>","code":"var assign = sendLocationDelegate('assign')","params":[{"type":"param","types":["Request"],"name":"req","description":"the request to replace the current location with, either a string or a Davis.Request."}],"has_params":true,"tags":[{"type":"param","types":["Request"],"name":"req","description":"the request to replace the current location with, either a string or a Davis.Request."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"module":false,"parent":"location","related":{"href":""},"has_related":true},{"id":"42-1342444637943","name":"replace","signiture":"replace","type":"declaration","ctx":{"type":"declaration","name":"replace","value":"sendLocationDelegate('replace')","string":"replace"},"description":{"full":"<p>Delegates to the locationDelegate.replace method.</p>\n\n<p>This should replace the current location with that of the passed request.<br />Ideally it should not create a new entry in the browsers history.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>","summary":"<p>Delegates to the locationDelegate.replace method.</p>","body":"<p>This should replace the current location with that of the passed request.<br />Ideally it should not create a new entry in the browsers history.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>"},"full_description":"<p>Delegates to the locationDelegate.replace method.</p>\n\n<p>This should replace the current location with that of the passed request. Ideally it should not create a new entry in the browsers history.</p>\n\n<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>","code":"var replace = sendLocationDelegate('replace')","params":[{"type":"param","types":["Request"],"name":"req","description":"the request to replace the current location with, either a string or a Davis.Request."}],"has_params":true,"tags":[{"type":"param","types":["Request"],"name":"req","description":"the request to replace the current location with, either a string or a Davis.Request."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"module":false,"parent":"location","related":{"href":""},"has_related":true},{"id":"43-1342444637943","name":"onChange","signiture":"onChange()","type":"function","ctx":{"type":"function","name":"onChange","string":"onChange()"},"description":{"full":"<p>Delegates to the locationDelegate.onChange method.</p>\n\n<p>This should add a callback that will be called any time the location changes.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>","summary":"<p>Delegates to the locationDelegate.onChange method.</p>","body":"<p>This should add a callback that will be called any time the location changes.<br />The handler function will be called with a request param which is an instance of Davis.Request.</p>"},"full_description":"<p>Delegates to the locationDelegate.onChange method.</p>\n\n<p>This should add a callback that will be called any time the location changes. The handler function will be called with a request param which is an instance of Davis.Request.</p>","code":"function onChange(handler) {\n    locationDelegate.onChange(handler)\n  }","params":[{"type":"param","types":["Function"],"name":"handler","description":"callback function to be called on location chnage."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"handler","description":"callback function to be called on location chnage."},{"type":"see","local":"Davis.Request","visibility":"Davis.Request"},{"type":"memberOf","parent":"location"}],"module":false,"parent":"location","related":{"href":""},"has_related":true}]},{"id":"44-1342444637943","name":"Request","signiture":"Request()","type":"function","ctx":{"type":"function","name":"Request","string":"Request()"},"description":{"full":"<p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes<br />and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>\n\n<p>A request will have a params object which will contain all query params and form params, any named<br />params in a routes path will also be added to the requests params object.  Also included is support<br />for rails style nested form params.</p>\n\n<p>By default the request method will be taken from the method attribute for forms or will be defaulted<br />to 'get' for links, however there is support for using a hidden field called _method in your forms<br />to set the correct reqeust method.</p>\n\n<p>Simple get requests can be created by just passing a path when initializing a request, to set the method<br />or title you have to pass in an object.</p>\n\n<p>Example</p>\n\n<pre><code>var request = new Davis.Request (\"/foo/12\")\n\nvar request = new Davis.Request (\"/foo/12\", {title: 'foo', method: 'POST'})\n\nvar request = new Davis.Request({\n  title: \"foo\",\n  fullPath: \"/foo/12\",\n  method: \"get\"\n})\n</code></pre>","summary":"<p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes<br />and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>","body":"<p>A request will have a params object which will contain all query params and form params, any named<br />params in a routes path will also be added to the requests params object.  Also included is support<br />for rails style nested form params.</p>\n\n<p>By default the request method will be taken from the method attribute for forms or will be defaulted<br />to 'get' for links, however there is support for using a hidden field called _method in your forms<br />to set the correct reqeust method.</p>\n\n<p>Simple get requests can be created by just passing a path when initializing a request, to set the method<br />or title you have to pass in an object.</p>\n\n<p>Example</p>\n\n<pre><code>var request = new Davis.Request (\"/foo/12\")\n\nvar request = new Davis.Request (\"/foo/12\", {title: 'foo', method: 'POST'})\n\nvar request = new Davis.Request({\n  title: \"foo\",\n  fullPath: \"/foo/12\",\n  method: \"get\"\n})\n</code></pre>"},"full_description":"<p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>\n\n<p>A request will have a params object which will contain all query params and form params, any named params in a routes path will also be added to the requests params object.  Also included is support for rails style nested form params.</p>\n\n<p>By default the request method will be taken from the method attribute for forms or will be defaulted to 'get' for links, however there is support for using a hidden field called _method in your forms to set the correct reqeust method.</p>\n\n<p>Simple get requests can be created by just passing a path when initializing a request, to set the method or title you have to pass in an object.</p>\n\n<p>Example</p>\n\n<pre><code>var request = new Davis.Request (\"/foo/12\")\n\nvar request = new Davis.Request (\"/foo/12\", {title: 'foo', method: 'POST'})\n\nvar request = new Davis.Request({\n  title: \"foo\",\n  fullPath: \"/foo/12\",\n  method: \"get\"\n})\n</code></pre>","code":"var Request = function (fullPath, opts) {\n    if (typeof fullPath == 'object') {\n      opts = fullPath\n      fullPath = opts.fullPath\n      delete opts.fullPath\n    }\n\n    var raw = Davis.$.extend({}, {\n      title: \"\",\n      fullPath: fullPath,\n      method: \"get\"\n    }, opts)\n\n    var self = this;\n    this.raw = raw;\n    this.params = {};\n    this.title = raw.title;\n    this.queryString = raw.fullPath.split(\"?\")[1];\n    this._staleCallback = function () {};\n\n    if (this.queryString) {\n      Davis.utils.forEach(this.queryString.split(\"&\"), function (keyval) {\n        var paramName = keyval.split(\"=\")[0],\n            paramValue = keyval.split(\"=\")[1],\n            nestedParamRegex = /^(\\w+)\\[(\\w+)?\\](\\[\\])?/,\n            nested;\n        if (nested = nestedParamRegex.exec(paramName)) {\n          var paramParent = nested[1];\n          var paramName = nested[2];\n          var isArray = !!nested[3];\n          var parentParams = self.params[paramParent] || {};\n\n          if (isArray) {\n            parentParams[paramName] = parentParams[paramName] || [];\n            parentParams[paramName].push(decodeURIComponent(paramValue));\n            self.params[paramParent] = parentParams;\n          } else if (!paramName && !isArray) {\n            parentParams = self.params[paramParent] || []\n            parentParams.push(decodeURIComponent(paramValue))\n            self.params[paramParent] = parentParams\n          } else {\n            parentParams[paramName] = decodeURIComponent(paramValue);\n            self.params[paramParent] = parentParams;\n          }\n        } else {\n          self.params[paramName] = decodeURIComponent(paramValue);\n        };\n\n      });\n    };\n\n    raw.fullPath = raw.fullPath.replace(/^https?:\\/\\/.+?\\//, '/');\n\n    this.method = (this.params._method || raw.method).toLowerCase();\n\n    this.path = raw.fullPath\n      .replace(/\\?.+$/, \"\")  // Remove the query string\n      .replace(/^https?:\\/\\/[^\\/]+/, \"\"); // Remove the protocol and host parts\n  \n    this.fullPath = raw.fullPath;\n\n    this.delegateToServer = raw.delegateToServer || Davis.noop;\n    this.isForPageLoad = raw.forPageLoad || false;\n\n    if (Request.prev) Request.prev.makeStale(this);\n    Request.prev = this;\n\n  };","params":[{"type":"param","types":["String"],"name":"fullPath","description":""},{"type":"param","types":["Object"],"name":"opts","description":"An optional object with a title or method proprty"}],"has_params":true,"tags":[{"type":"constructor"},{"type":"param","types":["String"],"name":"fullPath","description":""},{"type":"param","types":["Object"],"name":"opts","description":"An optional object with a title or method proprty"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"45-1342444637943","name":"redirect","signiture":"Request.prototype.redirect()","type":"method","ctx":{"type":"method","constructor":"Request","name":"redirect","string":"Request.prototype.redirect()"},"description":{"full":"<p>Redirects the current request to a new location.</p>\n\n<p>Calling redirect on an instance of Davis.Request will create a new request using the path and<br />title of the current request. Redirected requests always have a method of 'get'.</p>\n\n<p>The request created will replace the current request in the history stack.  Redirect is most<br />often useful inside a handler for a form submit.  After succesfully handling the form the app<br />can redirect to another path.  This means that the current form will not be re-submitted if<br />navigating through the history with the back or forward buttons because the request that the<br />submit generated has been replaced in the history stack.</p>\n\n<p>Example</p>\n\n<pre><code>this.post('/foo', function (req) {\n  processFormRequest(req.params)  // do something with the form request\n  req.redirect('/bar');\n})\n</code></pre>","summary":"<p>Redirects the current request to a new location.</p>","body":"<p>Calling redirect on an instance of Davis.Request will create a new request using the path and<br />title of the current request. Redirected requests always have a method of 'get'.</p>\n\n<p>The request created will replace the current request in the history stack.  Redirect is most<br />often useful inside a handler for a form submit.  After succesfully handling the form the app<br />can redirect to another path.  This means that the current form will not be re-submitted if<br />navigating through the history with the back or forward buttons because the request that the<br />submit generated has been replaced in the history stack.</p>\n\n<p>Example</p>\n\n<pre><code>this.post('/foo', function (req) {\n  processFormRequest(req.params)  // do something with the form request\n  req.redirect('/bar');\n})\n</code></pre>"},"full_description":"<p>Redirects the current request to a new location.</p>\n\n<p>Calling redirect on an instance of Davis.Request will create a new request using the path and title of the current request. Redirected requests always have a method of 'get'.</p>\n\n<p>The request created will replace the current request in the history stack.  Redirect is most often useful inside a handler for a form submit.  After succesfully handling the form the app can redirect to another path.  This means that the current form will not be re-submitted if navigating through the history with the back or forward buttons because the request that the submit generated has been replaced in the history stack.</p>\n\n<p>Example</p>\n\n<pre><code>this.post('/foo', function (req) {\n  processFormRequest(req.params)  // do something with the form request\n  req.redirect('/bar');\n})\n</code></pre>","code":"Request.prototype.redirect = function (path) {\n    Davis.location.replace(new Request ({\n      method: 'get',\n      fullPath: path,\n      title: this.title\n    }));\n  };","params":[{"type":"param","types":["String"],"name":"path","description":"The path to redirect the current request to"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"path","description":"The path to redirect the current request to"},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"46-1342444637943","name":"whenStale","signiture":"Request.prototype.whenStale()","type":"method","ctx":{"type":"method","constructor":"Request","name":"whenStale","string":"Request.prototype.whenStale()"},"description":{"full":"<p>Adds a callback to be called when the request is stale.<br />A request becomes stale when it is no longer the current request, this normally occurs when a<br />new request is triggered.  A request can be marked as stale manually if required.  The callback<br />passed to whenStale will be called with the new request that is making the current request stale.</p>\n\n<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives<br />a chance for views to hide themselves and unbind any event handlers etc.</p>\n\n<p>Example</p>\n\n<pre><code>this.get('/foo', function (req) {\n  var fooView = new FooView ()\n  fooView.render() // display the foo view\n  req.whenStale(function (nextReq) {\n    fooView.remove() // stop displaying foo view and unbind any events\n  })\n})\n</code></pre>","summary":"<p>Adds a callback to be called when the request is stale.<br />A request becomes stale when it is no longer the current request, this normally occurs when a<br />new request is triggered.  A request can be marked as stale manually if required.  The callback<br />passed to whenStale will be called with the new request that is making the current request stale.</p>","body":"<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives<br />a chance for views to hide themselves and unbind any event handlers etc.</p>\n\n<p>Example</p>\n\n<pre><code>this.get('/foo', function (req) {\n  var fooView = new FooView ()\n  fooView.render() // display the foo view\n  req.whenStale(function (nextReq) {\n    fooView.remove() // stop displaying foo view and unbind any events\n  })\n})\n</code></pre>"},"full_description":"<p>Adds a callback to be called when the request is stale. A request becomes stale when it is no longer the current request, this normally occurs when a new request is triggered.  A request can be marked as stale manually if required.  The callback passed to whenStale will be called with the new request that is making the current request stale.</p>\n\n<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives a chance for views to hide themselves and unbind any event handlers etc.</p>\n\n<p>Example</p>\n\n<pre><code>this.get('/foo', function (req) {\n  var fooView = new FooView ()\n  fooView.render() // display the foo view\n  req.whenStale(function (nextReq) {\n    fooView.remove() // stop displaying foo view and unbind any events\n  })\n})\n</code></pre>","code":"Request.prototype.whenStale = function (callback) {\n    this._staleCallback = callback;\n  }","params":[{"type":"param","types":["Function"],"name":"callback","description":"A single callback that will be called when the request becomes stale."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"callback","description":"A single callback that will be called when the request becomes stale."},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"47-1342444637943","name":"makeStale","signiture":"Request.prototype.makeStale()","type":"method","ctx":{"type":"method","constructor":"Request","name":"makeStale","string":"Request.prototype.makeStale()"},"description":{"full":"<p>Mark the request as stale.</p>\n\n<p>This will cause the whenStale callback to be called.</p>","summary":"<p>Mark the request as stale.</p>","body":"<p>This will cause the whenStale callback to be called.</p>"},"full_description":"<p>Mark the request as stale.</p>\n\n<p>This will cause the whenStale callback to be called.</p>","code":"Request.prototype.makeStale = function (req) {\n    this._staleCallback.call(req, req);\n  }","params":[{"type":"param","types":["Davis.Request"],"name":"req","description":"The next request that has been recieved."}],"has_params":true,"tags":[{"type":"param","types":["Davis.Request"],"name":"req","description":"The next request that has been recieved."},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"48-1342444637943","name":"location","signiture":"Request.prototype.location()","type":"method","ctx":{"type":"method","constructor":"Request","name":"location","string":"Request.prototype.location()"},"description":{"full":"<p>Returns the location or path that should be pushed onto the history stack. </p>\n\n<p>For get requests this will be the same as the path, for post, put, delete and state requests this will<br />be blank as no location should be pushed onto the history stack.</p>","summary":"<p>Returns the location or path that should be pushed onto the history stack. </p>","body":"<p>For get requests this will be the same as the path, for post, put, delete and state requests this will<br />be blank as no location should be pushed onto the history stack.</p>"},"full_description":"<p>Returns the location or path that should be pushed onto the history stack. </p>\n\n<p>For get requests this will be the same as the path, for post, put, delete and state requests this will be blank as no location should be pushed onto the history stack.</p>","code":"Request.prototype.location = function () {\n    return (this.method === 'get') ? this.fullPath : ''\n  }","params":[],"has_params":false,"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"49-1342444637943","name":"toString","signiture":"Request.prototype.toString()","type":"method","ctx":{"type":"method","constructor":"Request","name":"toString","string":"Request.prototype.toString()"},"description":{"full":"<p>Converts the request to a string representation of itself by combining the method and fullPath<br />attributes.</p>","summary":"<p>Converts the request to a string representation of itself by combining the method and fullPath<br />attributes.</p>","body":""},"full_description":"<p>Converts the request to a string representation of itself by combining the method and fullPath attributes.</p>","code":"Request.prototype.toString = function () {\n    return [this.method.toUpperCase(), this.path].join(\" \")\n  };","params":[],"has_params":false,"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"50-1342444637943","name":"toJSON","signiture":"Request.prototype.toJSON()","type":"method","ctx":{"type":"method","constructor":"Request","name":"toJSON","string":"Request.prototype.toJSON()"},"description":{"full":"<p>Converts the request to a plain object which can be converted to a JSON string.</p>\n\n<p>Used when pushing a request onto the history stack.</p>","summary":"<p>Converts the request to a plain object which can be converted to a JSON string.</p>","body":"<p>Used when pushing a request onto the history stack.</p>"},"full_description":"<p>Converts the request to a plain object which can be converted to a JSON string.</p>\n\n<p>Used when pushing a request onto the history stack.</p>","code":"Request.prototype.toJSON = function () {\n    return {\n      title: this.raw.title,\n      fullPath: this.raw.fullPath,\n      method: this.raw.method\n    }\n  }","params":[],"has_params":false,"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true},{"id":"51-1342444637943","name":"forPageLoad","signiture":"Request.forPageLoad()","type":"method","ctx":{"type":"method","receiver":"Request","name":"forPageLoad","string":"Request.forPageLoad()"},"description":{"full":"<p>Creates a new request for the page on page load.</p>\n\n<p>This is required because usually requests are generated from clicking links or submitting forms<br />however this doesn't happen on a page load but should still be considered a request that the <br />JavaScript app should handle.</p>","summary":"<p>Creates a new request for the page on page load.</p>","body":"<p>This is required because usually requests are generated from clicking links or submitting forms<br />however this doesn't happen on a page load but should still be considered a request that the <br />JavaScript app should handle.</p>"},"full_description":"<p>Creates a new request for the page on page load.</p>\n\n<p>This is required because usually requests are generated from clicking links or submitting forms however this doesn't happen on a page load but should still be considered a request that the  JavaScript app should handle.</p>","code":"Request.forPageLoad = function () {\n    return new this ({\n      method: 'get',\n      // fullPath: window.location.pathname,\n      fullPath: Davis.location.current(),\n      title: document.title,\n      forPageLoad: true\n    });\n  }","params":[],"has_params":false,"tags":[{"type":"returns"},{"type":"memberOf","parent":"Request"}],"module":false,"parent":"Request","related":{"href":""},"has_related":true}]},{"id":"52-1342444637943","name":"App","signiture":"App()","type":"function","ctx":{"type":"function","name":"App","string":"App()"},"description":{"full":"<p>Constructor for Davis.App</p>","summary":"<p>Constructor for Davis.App</p>","body":""},"full_description":"<p>Constructor for Davis.App</p>","code":"function App() {\n    this.running = false;\n    this.boundToInternalEvents = false;\n\n    this.use(Davis.listener)\n    this.use(Davis.event)\n    this.use(Davis.router)\n    this.use(Davis.logger)\n  };","params":[],"has_params":false,"tags":[{"type":"constructor"},{"type":"returns"}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"53-1342444637943","name":"configure","signiture":"App.prototype.configure()","type":"method","ctx":{"type":"method","constructor":"App","name":"configure","string":"App.prototype.configure()"},"description":{"full":"<p>A convinience function for changing the apps default settings.</p>\n\n<p>Should be used before starting the app to ensure any new settings<br />are picked up and used.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.configure(function (config) {\n  config.linkSelector = 'a.davis'\n  config.formSelector = 'form.davis'\n})\n</code></pre>","summary":"<p>A convinience function for changing the apps default settings.</p>","body":"<p>Should be used before starting the app to ensure any new settings<br />are picked up and used.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.configure(function (config) {\n  config.linkSelector = 'a.davis'\n  config.formSelector = 'form.davis'\n})\n</code></pre>"},"full_description":"<p>A convinience function for changing the apps default settings.</p>\n\n<p>Should be used before starting the app to ensure any new settings are picked up and used.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.configure(function (config) {\n  config.linkSelector = 'a.davis'\n  config.formSelector = 'form.davis'\n})\n</code></pre>","code":"App.prototype.configure = function(config) {\n    config.call(this.settings, this.settings);\n  };","params":[{"type":"param","types":["Function"],"name":"config","description":"This function will be executed with the context bound to the apps setting object, this will also be passed as the first argument to the function."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"config","description":"This function will be executed with the context bound to the apps setting object, this will also be passed as the first argument to the function."}],"module":false,"parent":"App","related":{"href":""},"has_related":true},{"id":"54-1342444637943","name":"use","signiture":"App.prototype.use()","type":"method","ctx":{"type":"method","constructor":"App","name":"use","string":"App.prototype.use()"},"description":{"full":"<p>Method to include a plugin in this app.</p>\n\n<p>A plugin is just a function that will be evaluated in the context of the app.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.use(Davis.title)\n</code></pre>","summary":"<p>Method to include a plugin in this app.</p>","body":"<p>A plugin is just a function that will be evaluated in the context of the app.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.use(Davis.title)\n</code></pre>"},"full_description":"<p>Method to include a plugin in this app.</p>\n\n<p>A plugin is just a function that will be evaluated in the context of the app.</p>\n\n<h2>Example</h2>\n\n<pre><code>app.use(Davis.title)\n</code></pre>","code":"App.prototype.use = function(plugin) {\n    plugin.apply(this, Davis.utils.toArray(arguments, 1))\n  };","params":[{"type":"param","types":["Function"],"name":"plugin","description":"The plugin to use"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"plugin","description":"The plugin to use"}],"module":false,"parent":"App","related":{"href":""},"has_related":true},{"id":"55-1342444637943","name":"helpers","signiture":"App.prototype.helpers()","type":"method","ctx":{"type":"method","constructor":"App","name":"helpers","string":"App.prototype.helpers()"},"description":{"full":"<p>Method to add helper properties to all requests in the application.</p>\n\n<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request<br />methods.</p>","summary":"<p>Method to add helper properties to all requests in the application.</p>","body":"<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request<br />methods.</p>"},"full_description":"<p>Method to add helper properties to all requests in the application.</p>\n\n<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request methods.</p>","code":"App.prototype.helpers = function(helpers) {\n    for (property in helpers) {\n      if (helpers.hasOwnProperty(property)) Davis.Request.prototype[property] = helpers[property]\n    }\n  };","params":[{"type":"param","types":["Object"],"name":"helpers","description":"An object containing helpers to mixin to the request"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"helpers","description":"An object containing helpers to mixin to the request"}],"module":false,"parent":"App","related":{"href":""},"has_related":true},{"id":"56-1342444637943","name":"settings","signiture":"App.prototypesettings","type":"property","ctx":{"type":"property","constructor":"App","name":"settings","value":"{","string":"App.prototypesettings"},"description":{"full":"<p>Settings for the app.  These may be overriden directly or by using the configure<br />convinience method.</p>\n\n<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want<br />Davis to respond to.  These links will not trigger a normal http request.</p>\n\n<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>\n\n<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true<br />errors will be thrown so that the request will not be handled by JavaScript, the server will have<br />to provide a response.  When set to false errors in a route will be caught and the server will not<br />receive the request.</p>\n\n<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching<br />route.  If set to false Davis will allow the request to be passed to your server to handle if no matching<br />route can be found.</p>\n\n<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load.<br />by default this is set to false. A Davis.Request will not be generated with the path of the current<br />page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>","summary":"<p>Settings for the app.  These may be overriden directly or by using the configure<br />convinience method.</p>","body":"<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want<br />Davis to respond to.  These links will not trigger a normal http request.</p>\n\n<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>\n\n<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true<br />errors will be thrown so that the request will not be handled by JavaScript, the server will have<br />to provide a response.  When set to false errors in a route will be caught and the server will not<br />receive the request.</p>\n\n<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching<br />route.  If set to false Davis will allow the request to be passed to your server to handle if no matching<br />route can be found.</p>\n\n<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load.<br />by default this is set to false. A Davis.Request will not be generated with the path of the current<br />page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>"},"full_description":"<p>Settings for the app.  These may be overriden directly or by using the configure convinience method.</p>\n\n<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want Davis to respond to.  These links will not trigger a normal http request.</p>\n\n<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>\n\n<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true errors will be thrown so that the request will not be handled by JavaScript, the server will have to provide a response.  When set to false errors in a route will be caught and the server will not receive the request.</p>\n\n<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching route.  If set to false Davis will allow the request to be passed to your server to handle if no matching route can be found.</p>\n\n<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load. by default this is set to false. A Davis.Request will not be generated with the path of the current page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>","code":"App.prototype.settings = {\n    linkSelector: 'a',\n    formSelector: 'form',\n    throwErrors: true,\n    handleRouteNotFound: false,\n    generateRequestOnPageLoad: false\n  };","params":[],"has_params":false,"tags":[{"type":"see","local":"#configure","visibility":"#configure"}],"module":false,"parent":"App","related":{"name":"#configure","href":"#configure"},"has_related":true},{"id":"57-1342444637943","name":"start","signiture":"App.prototype.start()","type":"method","ctx":{"type":"method","constructor":"App","name":"start","string":"App.prototype.start()"},"description":{"full":"<p>Starts the app's routing.</p>\n\n<p>Apps created using the convinience Davis() function are automatically started.</p>\n\n<p>Starting the app binds all links and forms, so clicks and submits<br />create Davis requests that will be pushed onto the browsers history stack.  Browser history change<br />events will be picked up and the request that caused the change will be matched against the apps<br />routes and filters.</p>","summary":"<p>Starts the app's routing.</p>","body":"<p>Apps created using the convinience Davis() function are automatically started.</p>\n\n<p>Starting the app binds all links and forms, so clicks and submits<br />create Davis requests that will be pushed onto the browsers history stack.  Browser history change<br />events will be picked up and the request that caused the change will be matched against the apps<br />routes and filters.</p>"},"full_description":"<p>Starts the app's routing.</p>\n\n<p>Apps created using the convinience Davis() function are automatically started.</p>\n\n<p>Starting the app binds all links and forms, so clicks and submits create Davis requests that will be pushed onto the browsers history stack.  Browser history change events will be picked up and the request that caused the change will be matched against the apps routes and filters.</p>","code":"App.prototype.start = function(){\n    var self = this;\n\n    if (this.running) return\n\n    if (!Davis.supported()) {\n      this.trigger('unsupported')\n      return\n    };\n\n    var runFilterWith = function (request) {\n      return function (filter) {\n        var result = filter.run(request, request);\n        return (typeof result === \"undefined\" || result);\n      }\n    }\n\n    var beforeFiltersPass = function (request) {\n      return Davis.utils.every(\n        self.lookupBeforeFilter(request.method, request.path),\n        runFilterWith(request)\n      )\n    }\n\n    var handleRequest = function (request) {\n      if (beforeFiltersPass(request)) {\n        self.trigger('lookupRoute', request)\n        var route = self.lookupRoute(request.method, request.path);\n        if (route) {\n          self.trigger('runRoute', request, route);\n\n          try {\n            route.run(request)\n            self.trigger('routeComplete', request, route)\n          } catch (error) {\n            self.trigger('routeError', request, route, error)\n          }\n\n          Davis.utils.every(\n            self.lookupAfterFilter(request.method, request.path),\n            runFilterWith(request)\n          );\n\n        } else {\n          self.trigger('routeNotFound', request);\n        }\n      } else {\n        self.trigger('requestHalted', request)\n      }\n    }\n\n    var bindToInternalEvents = function () {\n      self\n        .bind('runRoute', function (request) {\n          self.logger.info(\"runRoute: \" + request.toString());\n        })\n        .bind('routeNotFound', function (request) {\n          if (!self.settings.handleRouteNotFound && !request.isForPageLoad) {\n            self.stop()\n            request.delegateToServer()\n          };\n          self.logger.warn(\"routeNotFound: \" + request.toString());\n        })\n        .bind('start', function () {\n          self.logger.info(\"application started\")\n        })\n        .bind('stop', function () {\n          self.logger.info(\"application stopped\")\n        })\n        .bind('routeError', function (request, route, error) {\n          if (self.settings.throwErrors) throw(error)\n          self.logger.error(error.message, error.stack)\n        });\n\n      Davis.location.onChange(function (req) {\n        handleRequest(req)\n      });\n\n      self.boundToInternalEvents = true\n    }\n\n    if (!this.boundToInternalEvents) bindToInternalEvents()\n\n    this.listen();\n    this.trigger('start')\n    this.running = true;\n\n    if (this.settings.generateRequestOnPageLoad) handleRequest(Davis.Request.forPageLoad())\n\n  };","params":[],"has_params":false,"tags":[],"module":false,"parent":"App","has_related":false},{"id":"58-1342444637943","name":"stop","signiture":"App.prototype.stop()","type":"method","ctx":{"type":"method","constructor":"App","name":"stop","string":"App.prototype.stop()"},"description":{"full":"<p>Stops the app's routing.</p>\n\n<p>Stops the app listening to clicks and submits on all forms and links found using the current<br />apps settings.</p>","summary":"<p>Stops the app's routing.</p>","body":"<p>Stops the app listening to clicks and submits on all forms and links found using the current<br />apps settings.</p>"},"full_description":"<p>Stops the app's routing.</p>\n\n<p>Stops the app listening to clicks and submits on all forms and links found using the current apps settings.</p>","code":"App.prototype.stop = function() {\n    this.unlisten();\n    this.trigger('stop')\n    this.running = false\n  };\n\n  return App;\n})()","params":[],"has_params":false,"tags":[],"module":false,"parent":"App","has_related":false}]}]
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript" charset="utf-8"></script>

  <script type="text/javascript" charset="utf-8">
    // lunr.js version: 0.0.4
    // (c) 2011 Oliver Nightingale
    //
    //  Released under MIT license.
    //
    var Lunr=function(c,f){var b=new Lunr.Index(c);f.call(b,b);return b};
    Lunr.utils={uniq:function(c){if(!c)return[];return c.reduce(function(c,b){c.indexOf(b)===-1&&c.push(b);return c},[])},intersect:function(c){var f=[].slice.call(arguments,1);return this.uniq(c).filter(function(b){return f.every(function(a){return a.indexOf(b)>=0})})},detect:function(c,f,b){for(var a=c.length,g=null,d=0;d<a;d++)if(f.call(b,c[d],d,c)){g=c[d];break}return g},copy:function(c){return Object.keys(c).reduce(function(f,b){f[b]=c[b];return f},{})}};
    Lunr.Trie=function(){var c=function(){this.children={};this.values=[]};c.prototype={childForKey:function(b){var a=this.children[b];a||(a=new c,this.children[b]=a);return a}};var f=function(){this.root=new c};f.prototype={get:function(b){var a=this;return this.keys(b).reduce(function(c,d){a.getNode(d).values.forEach(function(a){a=Lunr.utils.copy(a);if(b===d)a.exact=!0;c.push(a)});return c},[])},getNode:function(b){var a=function(b,d){if(!d.length)return b;return a(b.childForKey(d.charAt(0)),d.slice(1))};
    return a(this.root,b)},keys:function(b){var a=[];b=b||"";var c=function(b,e){b.values.length&&a.push(e);Object.keys(b.children).forEach(function(a){c(b.children[a],e+a)})};c(this.getNode(b),b);return a},set:function(b,a){var c=function(b,e){if(!e.length)return b.values.push(a);c(b.childForKey(e.charAt(0)),e.slice(1))};return c(this.root,b)}};return f}();Lunr.Index=function(c){this.name=c;this.refName="id";this.fields={};this.trie=new Lunr.Trie};
    Lunr.Index.prototype={add:function(c){(new Lunr.Document(c,this.refName,this.fields)).words().forEach(function(c){this.trie.set(c.id,c.docs[0])},this)},field:function(c,f){this.fields[c]=f||{multiplier:1}},ref:function(c){this.refName=c},search:function(c){if(!c)return[];c=c.split(" ").map(function(c){c=new Lunr.Word(c);if(!c.isStopWord())return c.toString()}).filter(function(c){return c}).map(function(c){return this.trie.get(c).sort(function(b,a){if(b.exact&&a.exact===void 0)return-1;if(a.exact&&
    b.exact===void 0)return 1;if(b.score<a.score)return 1;if(b.score>a.score)return-1;return 0}).map(function(b){return b.documentId})},this);return Lunr.utils.intersect.apply(Lunr.utils,c)}};Lunr.Document=function(c,f,b){this.original=c;this.fields=b;this.ref=c[f]};
    Lunr.Document.prototype={asJSON:function(){return{id:this.ref,words:this.words().map(function(c){return c.id}),original:this.original}},words:function(){var c=this,f={};Object.keys(this.fields).forEach(function(b){c.original[b].split(/\b/g).filter(function(a){return!!a.match(/\w/)}).map(function(a){a=new Lunr.Word(a);if(!a.isStopWord())return a.toString()}).filter(function(a){return a}).forEach(function(a){f[a]||(f[a]={score:0,ref:c.ref});f[a].score+=c.fields[b].multiplier})});return Object.keys(f).map(function(b){return{id:b,
    docs:[{score:f[b].score,documentId:c.ref}]}})}};Lunr.Word=function(c){this.raw=c;this.out=this.raw.replace(/^\W+/,"").replace(/\W+$/,"").toLowerCase()};Lunr.Word.stopWords=["the","of","to","and","a","in","is","it","you","that","this"];
    Lunr.Word.prototype={isStopWord:function(){return Lunr.Word.stopWords.indexOf(this.raw.toLowerCase())!==-1},toString:function(){if(!this.isStopWord())return this.stem(),this.out},stem:function(){var c={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",
    ful:"",ness:""};return function(){var b,a,g,d=g=this.out;if(g.length<3)return g;var e,h;g=g.substr(0,1);g=="y"&&(d=g.toUpperCase()+d.substr(1));e=/^(.+?)(ss|i)es$/;a=/^(.+?)([^s])s$/;e.test(d)?d=d.replace(e,"$1$2"):a.test(d)&&(d=d.replace(a,"$1$2"));e=/^(.+?)eed$/;a=/^(.+?)(ed|ing)$/;e.test(d)?(a=e.exec(d),e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(a[1])&&(e=/.$/,d=d.replace(e,""))):a.test(d)&&(a=a.exec(d),b=a[1],a=/^([^aeiou][^aeiouy]*)?[aeiouy]/,a.test(b)&&(d=b,a=/(at|bl|iz)$/,
    h=/([^aeiouylsz])\1$/,b=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,a.test(d)?d+="e":h.test(d)?(e=/.$/,d=d.replace(e,"")):b.test(d)&&(d+="e")));e=/^(.+?)y$/;e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy]/,e.test(b)&&(d=b+"i"));e=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+c[a]));
    e=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+f[a]));e=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;a=/^(.+?)(s|t)(ion)$/;e.test(d)?(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b)):a.test(d)&&(a=a.exec(d),b=a[1]+a[2],a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,
    a.test(b)&&(d=b));e=/^(.+?)e$/;if(e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*([aeiouy][aeiou]*)?$/,h=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,e.test(b)||a.test(b)&&!h.test(b)))d=b;e=/ll$/;a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/;e.test(d)&&a.test(d)&&(e=/.$/,d=d.replace(e,""));g=="y"&&(d=g.toLowerCase()+
    d.substr(1));this.out=d}}()};
  </script>

  <script type="text/javascript" charset="utf-8">
    var idx = Lunr('methods', function () {
      this.ref('id')
      this.field('name', { multiplier: 10 })
      this.field('parent', { multiplier: 5 })
      this.field('full_description')
    })

    var methods = raw.reduce(function (memo, module) {
      return memo.concat(module.methods)
    }, [])

    methods.forEach(function (method) {
      idx.add(method)
    })

    $(document).ready(function () {

      var search = function (term) {
        return idx.search(term).map(function (id) {
          return methods.filter(function (method) {
            return method.id === id
          })[0]
        })
      }

      var searchResults = $('#search-results')

      $('#search-input').keyup(function () {
        var query = $(this).val(),
            results = search(query)

        if (!results.length) {
          searchResults.empty()
          return
        };

        var resultsList = results.reduce(function (ul, result) {
          var li = $('<li>').append($('<a>', {
            href: '#' + result.name,
            text: result.name
          }))

          ul.append(li)

          return ul
        }, $('<ul>'))

        searchResults.html(resultsList)
      })
    })
  </script>

  <style type="text/css" media="screen">
    body {
  font-family: 'Helvetica Neue';
  color: #333;
}

a {
  color: #0f4bf0;
}

header h1 {
  border-top: 4px solid #333;
  font-size: 2.6em;
}

header .version {
  font-size: 0.6em;
}

.main > header {
  margin-bottom: 40px;
}

article {
  margin-bottom: 10px;
  padding-bottom: 30px;
}

article header h2 {
  border-top: 3px solid #333;
  font-size: 2em;
  padding-top: 5px;
}

article > section {
  margin-bottom: 30px;
}

article section h3 {
  font-size: 1em;
}

article section header h3 {
  padding-top: 2px;
  font-size: 1.2em;
  margin-bottom: 5px;
  border-top: 2px solid #333;
}

article section header h4 {
  font-size: 0.9em;
  font-family: courier;
  margin: 2px 0 5px 0;
}

@-webkit-keyframes highlight {
  from {
    background-color: #Ffff66;
  }

  to {
    background-color: white;
  }
}

section.method:target {
  -webkit-animation-duration: 1s;
  -webkit-animation-name: highlight;
}

section header .type, section header .related {
  margin-top: 0px;
  font-size: 0.8em;
}

section.params h4, section.source h4 {
  margin-top: 5px;
  margin-bottom: 2px;
  font-size: 0.9em;
}

section.params ul {
  margin-top: 2px;
}

a.show-source {
  font-size: 0.8em;
}

.wrap {
  width: 960px;
  margin: 0 auto;
}

.main {
  width: 760px;
  float: left;
}

.search {
  margin-top: 10px;
  float: right;
}

#search-input {
  width: 200px;
}

#search-results {
  position: relative;
}

#search-results ul {
  width: 200px;
  position: absolute;
  top: 0px;
  left: 0px;
  background-color: white;
  border: 1px solid #ccc;
  list-style: none;
  padding: 0;
  margin-top: 0;
  font-size: 0.9em;
}

#search-results li {
  padding: 5px;
}

#search-results li:hover {
  background-color: #eee;
  cursor: pointer;
}

#search-results li a {
  text-decoration: none;
  width: 200px;
  display: block;
}

p {
  line-height: 1.4em;
}

nav {
  padding-top: 15px;
  float: left;
  width: 165px;
  margin-right: 30px;
  text-align: right;
  font-size: 0.8em;
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

nav ul h3 {
  margin-bottom: 5px;
  border-top: 2px solid #CCC;
  padding-top: 2px;
}

nav ul ul li {
  padding: 2px 0;
}

pre {
  background-color: rgba(0,0,0,0.1);
  padding: 8px;
}

code .keyword, code .special {
  font-weight: bold;
  color: black;
}

code .string, code .regexp {
  color: green
}

code .class { 
  color: blue
}

code .number {
  color: red
}

code .comment {
  color: grey;
  font-style: italic;
}
  </style>
</head>
<body>
  <div class='wrap'>


    <nav>
      <ul>
        
          <li>
            <a href='#listener'>
              <h3>listener</h3>
            </a>

            <ul>
              
                <li><a href='#listen'>listen</a></li>
              
                <li><a href='#unlisten'>unlisten</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#event'>
              <h3>event</h3>
            </a>

            <ul>
              
                <li><a href='#bind'>bind</a></li>
              
                <li><a href='#trigger'>trigger</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#logger'>
              <h3>logger</h3>
            </a>

            <ul>
              
                <li><a href='#error'>error</a></li>
              
                <li><a href='#info'>info</a></li>
              
                <li><a href='#warn'>warn</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Route'>
              <h3>Route</h3>
            </a>

            <ul>
              
                <li><a href='#match'>match</a></li>
              
                <li><a href='#reset'>reset</a></li>
              
                <li><a href='#run'>run</a></li>
              
                <li><a href='#toString'>toString</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#router'>
              <h3>router</h3>
            </a>

            <ul>
              
                <li><a href='#route'>route</a></li>
              
                <li><a href='#get'>get</a></li>
              
                <li><a href='#post'>post</a></li>
              
                <li><a href='#put'>put</a></li>
              
                <li><a href='#del'>del</a></li>
              
                <li><a href='#state'>state</a></li>
              
                <li><a href='#scope'>scope</a></li>
              
                <li><a href='#trans'>trans</a></li>
              
                <li><a href='#before'>before</a></li>
              
                <li><a href='#after'>after</a></li>
              
                <li><a href='#lookupBeforeFilter'>lookupBeforeFilter</a></li>
              
                <li><a href='#lookupAfterFilter'>lookupAfterFilter</a></li>
              
                <li><a href='#lookupRoute'>lookupRoute</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#history'>
              <h3>history</h3>
            </a>

            <ul>
              
                <li><a href='#onChange'>onChange</a></li>
              
                <li><a href='#assign'>assign</a></li>
              
                <li><a href='#replace'>replace</a></li>
              
                <li><a href='#current'>current</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#location'>
              <h3>location</h3>
            </a>

            <ul>
              
                <li><a href='#setLocationDelegate'>setLocationDelegate</a></li>
              
                <li><a href='#current'>current</a></li>
              
                <li><a href='#assign'>assign</a></li>
              
                <li><a href='#replace'>replace</a></li>
              
                <li><a href='#onChange'>onChange</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Request'>
              <h3>Request</h3>
            </a>

            <ul>
              
                <li><a href='#redirect'>redirect</a></li>
              
                <li><a href='#whenStale'>whenStale</a></li>
              
                <li><a href='#makeStale'>makeStale</a></li>
              
                <li><a href='#location'>location</a></li>
              
                <li><a href='#toString'>toString</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
                <li><a href='#forPageLoad'>forPageLoad</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#App'>
              <h3>App</h3>
            </a>

            <ul>
              
                <li><a href='#configure'>configure</a></li>
              
                <li><a href='#use'>use</a></li>
              
                <li><a href='#helpers'>helpers</a></li>
              
                <li><a href='#settings'>settings</a></li>
              
                <li><a href='#start'>start</a></li>
              
                <li><a href='#stop'>stop</a></li>
              
            </ul>
          </li>
        
      </ul>
    </nav>

    <div class='main'>
      <header>
        <div class='search'>
          <input type="search" id="search-input" placeholder="Search"></input>
          <div id="search-results"></div>
        </div>
        <h1>Davis.js <span class='version'>0.9.2</span></h1>
      </header>

      
        <article id='listener'>
          <header>
            <h2>listener</h2>
          </header>

          <section>
            <p>A module to bind to link clicks and form submits and turn what would normally be http requests into instances of Davis.Request.  These request objects are then pushed onto the history stack using the Davis.history module.</p>

<p>This module uses Davis.$, which by defualt is jQuery for its event binding and event object normalization. To use Davis with any, or no, JavaScript framework be sure to provide support for all the methods called on Davis.$.</p>
          </section>

          
            <section class='method' id='listen'>
              <header>
                <h3>listen</h3>
                <h4>this.listen()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#settings'>Davis.App.settings</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Binds to both link clicks and form submits using jQuery's deleagate.</p>

<p>Will catch all current and future links and forms.  Uses the apps settings for the selector to use for links and forms</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.listen = function () {
    Davis.$(document).delegate(this.settings.formSelector, 'submit', submitHandler)
    Davis.$(document).delegate(this.settings.linkSelector, 'click', clickHandler)
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='unlisten'>
              <header>
                <h3>unlisten</h3>
                <h4>this.unlisten()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#settings'>Davis.App.settings</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Unbinds all click and submit handlers that were attatched with listen.</p>

<p>Will efectivley stop the current app from processing any requests and all links and forms will have their default behaviour restored.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.unlisten = function () {
    Davis.$(document).undelegate(this.settings.linkSelector, 'click', clickHandler)
    Davis.$(document).undelegate(this.settings.formSelector, 'submit', submitHandler)
  }
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='event'>
          <header>
            <h2>event</h2>
          </header>

          <section>
            <p>A plugin that adds basic event capabilities to a Davis app, it is included by default.</p>
          </section>

          
            <section class='method' id='bind'>
              <header>
                <h3>bind</h3>
                <h4>this.bind()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>event - event name</li>
                  
                    <li>fn - callback</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Binds a callback to a named event.</p>

<p>The following events are triggered internally by Davis and can be bound to</p>

<ul>
<li>start : Triggered when the application is started</li>
<li>lookupRoute : Triggered before looking up a route. The request being looked up is passed as an argument</li>
<li>runRoute : Triggered before running a route. The request and route being run are passed as arguments</li>
<li>routeNotFound : Triggered if no route for the current request can be found. The current request is passed as an arugment</li>
<li>requestHalted : Triggered when a before filter halts the current request. The current request is passed as an argument</li>
<li>unsupported : Triggered when starting a Davis app in a browser that doesn't support html5 pushState</li>
</ul>

<p>Example</p>

<pre><code>app.bind('runRoute', function () {
  console.log('about to run a route')
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.bind = function (event, fn) {
    (callbacks[event] = callbacks[event] || []).push(fn);
    return this;
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='trigger'>
              <header>
                <h3>trigger</h3>
                <h4>this.trigger()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>event - event name</li>
                  
                    <li>... - </li>
                  
                </ul>
              </section>

              

              <section>
                <p>Triggers an event with the given arguments.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.trigger = function (event) {
    var args = Davis.utils.toArray(arguments, 1),
        handlers = callbacks[event];

    if (!handlers) return this

    for (var i = 0, len = handlers.length; i &lt; len; ++i) {
      handlers[i].apply(this, args)
    }

    return this;
  };
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='logger'>
          <header>
            <h2>logger</h2>
          </header>

          <section>
            <p>A plugin for enhancing the standard logging available through the console object. Automatically included in all Davis apps.</p>

<p>Generates log messages of varying severity in the format</p>

<p><code>[Sun Jan 23 2011 16:15:21 GMT+0000 (GMT)] &lt;message&gt;</code></p>
          </section>

          
            <section class='method' id='error'>
              <header>
                <h3>error</h3>
                <h4>error</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Prints an error message to the console if the console is available.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var error = logType('error')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='info'>
              <header>
                <h3>info</h3>
                <h4>info</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Prints an info message to the console if the console is available.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var info = logType('info')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='warn'>
              <header>
                <h3>warn</h3>
                <h4>warn</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Prints a warning message to the console if the console is available.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var warn = logType('warn')</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Route'>
          <header>
            <h2>Route</h2>
          </header>

          <section>
            <p>Davis.Routes are the main part of a Davis application.  They consist of an HTTP method, a path and a callback function.  When a link or a form that Davis has bound to are clicked or submitted a request is pushed on the history stack and a route that matches the path and method of the generated request is run.</p>

<p>The path for the route can consist of placeholders for attributes, these will then be available on the request.  Simple variables should be prefixed with a colan, and for splat style params use an asterisk.</p>

<p>Inside the callback function 'this' is bound to the request.</p>

<h2>Example</h2>

<pre><code>var route = new Davis.Route ('get', '/foo/:id', function (req) {
  var id = req.params['id']
  // do something interesting!
})

var route = new Davis.Route ('get', '/foo/*splat', function (req) {
  var id = req.params['splat']
  // splat will contain everything after the /foo/ in the path.
})
</code></pre>

<p>You can include any number of route level 'middleware' when defining routes.  These middlewares are run in order and need to explicitly call the next handler in the stack.  Using route middleware allows you to share common logic between routes and is also a good place to load any data or do any async calls keeping your main handler simple and focused.</p>

<h2>Example</h2>

<pre><code>var loadUser = function (req, next) {
  $.get('/users/current', function (user) {
    req.user = user
    next(req)
  })
}

var route = new Davis.Route ('get', '/foo/:id', loadUser, function (req) {
  renderUser(req.user)
})
</code></pre>
          </section>

          
            <section class='method' id='match'>
              <header>
                <h3>match</h3>
                <h4>Route.prototype.match()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>method - the method to match against</li>
                  
                    <li>path - the path to match against</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Tests whether or not a route matches a particular request.</p>

<h2>Example</h2>

<pre><code>route.match('get', '/foo/12')
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Route.prototype.match = function (method, path) {
    this.reset();
    return (this.method.test(method)) &amp;&amp; (this.path.test(path))
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='reset'>
              <header>
                <h3>reset</h3>
                <h4>Route.prototype.reset()</h4>
                <p class='type'>method</p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Resets the RegExps for method and path</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Route.prototype.reset = function () {
    this.method.lastIndex = 0;
    this.path.lastIndex = 0;
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='run'>
              <header>
                <h3>run</h3>
                <h4>Route.prototype.run()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Runs the callback associated with a particular route against the passed request.</p>

<p>Any named params in the request path are extracted, as per the routes path, and added onto the requests params object.</p>

<h2>Example</h2>

<pre><code>route.run(request)
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Route.prototype.run = function (request) {
    this.reset();
    var matches = this.path.exec(request.path);
    if (matches) {
      matches.shift();
      for (var i=0; i &lt; matches.length; i++) {
        request.params[this.paramNames[i]] = matches[i];
      };
    };

    var handlers = Davis.utils.map(this.handlers, function (handler, i) {
      return function (req) {
        return handler.call(req, req, handlers[i+1])
      }
    })

    return handlers[0](request)
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toString'>
              <header>
                <h3>toString</h3>
                <h4>Route.prototype.toString()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts the route to a string representation of itself by combining the method and path attributes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Route.prototype.toString = function () {
    return [this.method, this.path].join(' ');
  }</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='router'>
          <header>
            <h2>router</h2>
          </header>

          <section>
            <p>A decorator that adds convinience methods to a Davis.App for easily creating instances of Davis.Route and looking up routes for a particular request.</p>

<p>Provides get, post put and delete method shortcuts for creating instances of Davis.Routes with the corresponding method.  This allows simple REST styled routing for a client side JavaScript application.</p>

<h3>Example</h3>

<pre><code>app.get('/foo/:id', function (req) {
  // get the foo with id = req.params['id']
})

app.post('/foo', function (req) {
  // create a new instance of foo with req.params
})

app.put('/foo/:id', function (req) {
  // update the instance of foo with id = req.params['id']
})

app.del('/foo/:id', function (req) {
  // delete the instance of foo with id = req.params['id']
})
</code></pre>

<p>As well as providing convinience methods for creating instances of Davis.Routes the router also provides methods for creating special instances of routes called filters.  Before filters run before any matching route is run, and after filters run after any matched route has run. A before filter can return false to halt the running of any matched routes or other before filters.</p>

<p>A filter can take an optional path to match on, or without a path will match every request.</p>

<h3>Example</h3>

<pre><code>app.before('/foo/:id', function (req) {
  // will only run before request matching '/foo/:id'
})

app.before(function (req) {
  // will run before all routes
})

app.after('/foo/:id', function (req) {
  // will only run after routes matching '/foo/:id'
})

app.after(function (req) {
  // will run after all routes
})
</code></pre>

<p>Another special kind of route, called state routes, are also generated using the router.  State routes are for requests that will not change the current page location.  Instead the page location will remain the same but the current state of the page has changed.  This allows for states which the server will not be expected to know about and support.</p>

<h3>Example</h3>

<pre><code>app.state('/foo/:id', function (req) {
  // will run when the app transitions into the '/foo/:id' state.
})
</code></pre>

<p>Using the <code>trans</code> method an app can transition to these kind of states without changing the url location.</p>

<p>For convinience routes can be defined within a common base scope, this is useful for keeping your route definitions simpler and DRYer.  A scope can either cover the whole app, or just a subset of the routes.</p>

<h3>Example</h3>

<pre><code>app.scope('/foo', function () {
  this.get('/:id', function () {
    // will run for routes that match '/foo/:id'
  })
})
</code></pre>
          </section>

          
            <section class='method' id='route'>
              <header>
                <h3>route</h3>
                <h4>this.route()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>method - The method for this route.</li>
                  
                    <li>path - The path for this route.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Low level method for adding routes to your application.</p>

<p>If called with just a method will return a partially applied function that can create routes with that method.  This is used internally to provide shortcuts for get, post, put, delete and state routes.</p>

<p>You normally want to use the higher level methods such as get and post, but this can be useful for extending Davis to work with other kinds of requests.</p>

<h2>Example</h2>

<pre><code>app.route('get', '/foo', function (req) {
  // will run when a get request is made to '/foo'
})

app.patch = app.route('patch') // will return a function that can be used to handle requests with method of patch.
app.patch('/bar', function (req) {
  // will run when a patch request is made to '/bar'
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.route = function (method, path) {
    var createRoute = function (path) {
      var handlers = Davis.utils.toArray(arguments, 1),
          scope = scopePaths.join(''),
          route = new Davis.Route (method, scope + path, handlers)

      routeCollection.push(route)
      return route
    }

    return (arguments.length == 1) ? createRoute : createRoute.apply(this, Davis.utils.toArray(arguments, 1))
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='get'>
              <header>
                <h3>get</h3>
                <h4>this.get</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path for this route.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.route</code> for creating get routes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.get  = this.route('get')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='post'>
              <header>
                <h3>post</h3>
                <h4>this.post</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path for this route.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.route</code> for creating post routes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.post = this.route('post')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='put'>
              <header>
                <h3>put</h3>
                <h4>this.put</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path for this route.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.route</code> for creating put routes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.put  = this.route('put')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='del'>
              <header>
                <h3>del</h3>
                <h4>this.del</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path for this route.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.route</code> for creating delete routes.</p>

<p>delete is a reserved word in javascript so use the <code>del</code> method when creating a Davis.Route with a method of delete.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.del  = this.route('delete')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='state'>
              <header>
                <h3>state</h3>
                <h4>this.state</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path for this route, this will never be seen in the url bar.</li>
                  
                    <li>handler - The handler for this route, will be called with the request that triggered the route</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a state route into the apps route collection.</p>

<p>These special kind of routes are not triggered by clicking links or submitting forms, instead they are triggered manually by calling <code>trans</code>.</p>

<p>Routes added using the state method act in the same way as other routes except that they generate a route that is listening for requests that will not change the page location.</p>

<h2>Example</h2>

<pre><code>app.state('/foo/:id', function (req) {
  // will run when the app transitions into the '/foo/:id' state.
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.state = this.route('state');</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='scope'>
              <header>
                <h3>scope</h3>
                <h4>this.scope()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The prefix to use as the scope</li>
                  
                    <li>fn - A function that will be executed with the router as its context and the path</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Modifies the scope of the router.</p>

<p>If you have many routes that share a common path prefix you can use scope to reduce repeating that path prefix.</p>

<p>You can use <code>scope</code> in two ways, firstly you can set the scope for the whole app by calling scope before defining routes.  You can also provide a function to the scope method, and the scope will only apply to those routes defined within this function. It is  also possible to nest scopes within other scopes.</p>

<p>Example</p>

<pre><code>// using scope with a function
app.scope('/foo', function () {
  this.get('/bar', function (req) {
    // this route will have a path of '/foo/bar'
  })
})

// setting a global scope for the rest of the application
app.scope('/bar')

// using scope with a function
app.scope('/foo', function () {
  this.scope('/bar', function () {
    this.get('/baz', function (req) {
      // this route will have a path of '/foo/bar/baz'
    })
  })
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.scope = function (path, fn) {
    scopePaths.push(path)
    if (arguments.length == 1) return

    fn.call(this, this)
    scopePaths.pop()
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='trans'>
              <header>
                <h3>trans</h3>
                <h4>this.trans()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path that represents this state. This will not be seen in the url bar.</li>
                  
                    <li>data - Any additional data that should be sent with the request as params.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Transitions the app into the state identified by the passed path parameter.</p>

<p>This allows the app to enter states without changing the page path through a link click or form submit.  If there are handlers registered for this state, added by the <code>state</code> method, they will be triggered.</p>

<p>This method generates a request with a method of 'state', in all other ways this request is identical to those that are generated when clicking links etc.</p>

<p>States transitioned to using this method will not be able to be revisited directly with a page load as there is no url that represents the state.</p>

<p>An optional second parameter can be passed which will be available to any handlers in the requests params object.</p>

<p>Example</p>

<pre><code>app.trans('/foo/1')

app.trans('/foo/1', {
  "bar": "baz"
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.trans = function (path, data) {
    if (data) {
      var fullPath = [path, decodeURIComponent(Davis.$.param(data))].join('?')
    } else {
      var fullPath = path
    };

    var req = new Davis.Request({
      method: 'state',
      fullPath: fullPath,
      title: ''
    })

    Davis.location.assign(req)
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='before'>
              <header>
                <h3>before</h3>
                <h4>this.before</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The optionl path for this filter.</li>
                  
                    <li>handler - The handler for this filter, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.filter</code> for creating before filters.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.before = this.filter('before')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='after'>
              <header>
                <h3>after</h3>
                <h4>this.after</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The optionl path for this filter.</li>
                  
                    <li>handler - The handler for this filter, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.filter</code> for creating after filters.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.after = this.filter('after')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='lookupBeforeFilter'>
              <header>
                <h3>lookupBeforeFilter</h3>
                <h4>this.lookupBeforeFilter</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The optionl path for this filter.</li>
                  
                    <li>handler - The handler for this filter, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.lookupFilter</code> for looking up before filters.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.lookupBeforeFilter = this.lookupFilter('before')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='lookupAfterFilter'>
              <header>
                <h3>lookupAfterFilter</h3>
                <h4>this.lookupAfterFilter</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The optionl path for this filter.</li>
                  
                    <li>handler - The handler for this filter, will be called with the request that triggered the route.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience wrapper around <code>app.lookupFilter</code> for looking up after filters.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.lookupAfterFilter  = this.lookupFilter('after')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='lookupRoute'>
              <header>
                <h3>lookupRoute</h3>
                <h4>this.lookupRoute()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>method - the method to use when looking up a route</li>
                  
                    <li>path - the path to use when looking up a route</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Looks for the first route that matches the method and path from a request. Will only find and return the first matched route.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>this.lookupRoute = function (method, path) {
    return Davis.utils.filter(routeCollection, function (route) {
      return route.match(method, path)
    })[0];
  };
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='history'>
          <header>
            <h2>history</h2>
          </header>

          <section>
            <p>A module to normalize and enhance the window.pushState method and window.onpopstate event.</p>

<p>Adds the ability to bind to whenever a new state is pushed onto the history stack and normalizes both of these events into an onChange event.</p>
          </section>

          
            <section class='method' id='onChange'>
              <header>
                <h3>onChange</h3>
                <h4>onChange()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>handler - a function that will be called on push and pop state.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Bind to the history on change event.</p>

<p>This is not a native event but is fired any time a new state is pushed onto the history stack, the current history is replaced or a state is popped off the history stack. The handler function will be called with a request param which is an instance of Davis.Request.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function onChange(handler) {
    onPushState(handler);
    onPopState(wrapped(handler));
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='assign'>
              <header>
                <h3>assign</h3>
                <h4>assign</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>request - the location to be assinged as the current location.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Pushes a request onto the history stack.</p>

<p>This is used internally by Davis to push a new request resulting from either a form submit or a link click onto the history stack, it will also trigger the onpushstate event.</p>

<p>An instance of Davis.Request is expected to be passed, however any object that has a title and a path property will also be accepted.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var assign = changeStateWith('pushState')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='replace'>
              <header>
                <h3>replace</h3>
                <h4>replace</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>request - the location to replace the current location with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Replace the current state on the history stack.</p>

<p>This is used internally by Davis when performing a redirect.  This will trigger an onpushstate event.</p>

<p>An instance of Davis.Request is expected to be passed, however any object that has a title and a path property will also be accepted.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var replace = changeStateWith('replaceState')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='current'>
              <header>
                <h3>current</h3>
                <h4>current()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the current location for the application.</p>

<p>Davis.location delegates to this method for getting the apps current location.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function current() {
    return window.location.pathname + (window.location.search ? window.location.search : '')
  }</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='location'>
          <header>
            <h2>location</h2>
          </header>

          <section>
            <p>A module that acts as a delegator to any locationDelegate implementation.  This abstracts the details of what is being used for the apps routing away from the rest of the library.  This allows any kind of routing To be used with Davis as long as it can respond appropriatly to the given delegate methods.</p>

<p>A routing module must respond to the following methods</p>

<ul>
<li><strong>current</strong> : Should return the current location for the app</li>
<li><strong>assign</strong> : Should set the current location of the app based on the location of the passed request.</li>
<li><strong>replace</strong> : Should at least change the current location to the location of the passed request, for full compatibility it should not add any extra items in the history stack.</li>
<li><strong>onChange</strong> : Should add calbacks that will be fired whenever the location is changed.</li>
</ul>
          </section>

          
            <section class='method' id='setLocationDelegate'>
              <header>
                <h3>setLocationDelegate</h3>
                <h4>setLocationDelegate()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>the - location delegate to use.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Sets the current location delegate.</p>

<p>The passed delegate will be used for all Davis apps.  The delegate must respond to the following four methods <code>current</code>, <code>assign</code>, <code>replace</code> &amp; <code>onChange</code>.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function setLocationDelegate(delegate) {
    locationDelegate = delegate
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='current'>
              <header>
                <h3>current</h3>
                <h4>current()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Delegates to the locationDelegate.current method.</p>

<p>This should return the current location of the app.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function current() {
    return locationDelegate.current()
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='assign'>
              <header>
                <h3>assign</h3>
                <h4>assign</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>req - the request to replace the current location with, either a string or a Davis.Request.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Delegates to the locationDelegate.assign method.</p>

<p>This should set the current location for the app to that of the passed request object.</p>

<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var assign = sendLocationDelegate('assign')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='replace'>
              <header>
                <h3>replace</h3>
                <h4>replace</h4>
                <p class='type'>declaration</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>req - the request to replace the current location with, either a string or a Davis.Request.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Delegates to the locationDelegate.replace method.</p>

<p>This should replace the current location with that of the passed request. Ideally it should not create a new entry in the browsers history.</p>

<p>Can take either a Davis.Request or a string representing the path of the request to assign.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>var replace = sendLocationDelegate('replace')</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='onChange'>
              <header>
                <h3>onChange</h3>
                <h4>onChange()</h4>
                <p class='type'>function</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>handler - callback function to be called on location chnage.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Delegates to the locationDelegate.onChange method.</p>

<p>This should add a callback that will be called any time the location changes. The handler function will be called with a request param which is an instance of Davis.Request.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>function onChange(handler) {
    locationDelegate.onChange(handler)
  }</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Request'>
          <header>
            <h2>Request</h2>
          </header>

          <section>
            <p>Davis.Requests are created from click and submit events.  Davis.Requests are passed to Davis.Routes and are stored in the history stack.  They are instantiated by the Davis.listener module.</p>

<p>A request will have a params object which will contain all query params and form params, any named params in a routes path will also be added to the requests params object.  Also included is support for rails style nested form params.</p>

<p>By default the request method will be taken from the method attribute for forms or will be defaulted to 'get' for links, however there is support for using a hidden field called _method in your forms to set the correct reqeust method.</p>

<p>Simple get requests can be created by just passing a path when initializing a request, to set the method or title you have to pass in an object.</p>

<p>Example</p>

<pre><code>var request = new Davis.Request ("/foo/12")

var request = new Davis.Request ("/foo/12", {title: 'foo', method: 'POST'})

var request = new Davis.Request({
  title: "foo",
  fullPath: "/foo/12",
  method: "get"
})
</code></pre>
          </section>

          
            <section class='method' id='redirect'>
              <header>
                <h3>redirect</h3>
                <h4>Request.prototype.redirect()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>path - The path to redirect the current request to</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Redirects the current request to a new location.</p>

<p>Calling redirect on an instance of Davis.Request will create a new request using the path and title of the current request. Redirected requests always have a method of 'get'.</p>

<p>The request created will replace the current request in the history stack.  Redirect is most often useful inside a handler for a form submit.  After succesfully handling the form the app can redirect to another path.  This means that the current form will not be re-submitted if navigating through the history with the back or forward buttons because the request that the submit generated has been replaced in the history stack.</p>

<p>Example</p>

<pre><code>this.post('/foo', function (req) {
  processFormRequest(req.params)  // do something with the form request
  req.redirect('/bar');
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.redirect = function (path) {
    Davis.location.replace(new Request ({
      method: 'get',
      fullPath: path,
      title: this.title
    }));
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='whenStale'>
              <header>
                <h3>whenStale</h3>
                <h4>Request.prototype.whenStale()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>callback - A single callback that will be called when the request becomes stale.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a callback to be called when the request is stale. A request becomes stale when it is no longer the current request, this normally occurs when a new request is triggered.  A request can be marked as stale manually if required.  The callback passed to whenStale will be called with the new request that is making the current request stale.</p>

<p>Use the whenStale callback to 'teardown' the objects required for the current route, this gives a chance for views to hide themselves and unbind any event handlers etc.</p>

<p>Example</p>

<pre><code>this.get('/foo', function (req) {
  var fooView = new FooView ()
  fooView.render() // display the foo view
  req.whenStale(function (nextReq) {
    fooView.remove() // stop displaying foo view and unbind any events
  })
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.whenStale = function (callback) {
    this._staleCallback = callback;
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='makeStale'>
              <header>
                <h3>makeStale</h3>
                <h4>Request.prototype.makeStale()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>req - The next request that has been recieved.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Mark the request as stale.</p>

<p>This will cause the whenStale callback to be called.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.makeStale = function (req) {
    this._staleCallback.call(req, req);
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='location'>
              <header>
                <h3>location</h3>
                <h4>Request.prototype.location()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the location or path that should be pushed onto the history stack. </p>

<p>For get requests this will be the same as the path, for post, put, delete and state requests this will be blank as no location should be pushed onto the history stack.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.location = function () {
    return (this.method === 'get') ? this.fullPath : ''
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toString'>
              <header>
                <h3>toString</h3>
                <h4>Request.prototype.toString()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts the request to a string representation of itself by combining the method and fullPath attributes.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.toString = function () {
    return [this.method.toUpperCase(), this.path].join(&quot; &quot;)
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>Request.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts the request to a plain object which can be converted to a JSON string.</p>

<p>Used when pushing a request onto the history stack.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.prototype.toJSON = function () {
    return {
      title: this.raw.title,
      fullPath: this.raw.fullPath,
      method: this.raw.method
    }
  }</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='forPageLoad'>
              <header>
                <h3>forPageLoad</h3>
                <h4>Request.forPageLoad()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new request for the page on page load.</p>

<p>This is required because usually requests are generated from clicking links or submitting forms however this doesn't happen on a page load but should still be considered a request that the  JavaScript app should handle.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>Request.forPageLoad = function () {
    return new this ({
      method: 'get',
      // fullPath: window.location.pathname,
      fullPath: Davis.location.current(),
      title: document.title,
      forPageLoad: true
    });
  }</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='App'>
          <header>
            <h2>App</h2>
          </header>

          <section>
            <p>Constructor for Davis.App</p>
          </section>

          
            <section class='method' id='configure'>
              <header>
                <h3>configure</h3>
                <h4>App.prototype.configure()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>config - This function will be executed with the context bound to the apps setting object, this will also be passed as the first argument to the function.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>A convinience function for changing the apps default settings.</p>

<p>Should be used before starting the app to ensure any new settings are picked up and used.</p>

<h2>Example</h2>

<pre><code>app.configure(function (config) {
  config.linkSelector = 'a.davis'
  config.formSelector = 'form.davis'
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.configure = function(config) {
    config.call(this.settings, this.settings);
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='use'>
              <header>
                <h3>use</h3>
                <h4>App.prototype.use()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>plugin - The plugin to use</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Method to include a plugin in this app.</p>

<p>A plugin is just a function that will be evaluated in the context of the app.</p>

<h2>Example</h2>

<pre><code>app.use(Davis.title)
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.use = function(plugin) {
    plugin.apply(this, Davis.utils.toArray(arguments, 1))
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='helpers'>
              <header>
                <h3>helpers</h3>
                <h4>App.prototype.helpers()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>helpers - An object containing helpers to mixin to the request</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Method to add helper properties to all requests in the application.</p>

<p>Helpers will be added to the Davis.Request.prototype.  Care should be taken not to override any existing Davis.Request methods.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.helpers = function(helpers) {
    for (property in helpers) {
      if (helpers.hasOwnProperty(property)) Davis.Request.prototype[property] = helpers[property]
    }
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='settings'>
              <header>
                <h3>settings</h3>
                <h4>App.prototypesettings</h4>
                <p class='type'>property</p>
                
                  <p class='related'>See: <a href='##configure'>#configure</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Settings for the app.  These may be overriden directly or by using the configure convinience method.</p>

<p><code>linkSelector</code> is the jquery selector for all the links on the page that you want Davis to respond to.  These links will not trigger a normal http request.</p>

<p><code>formSelector</code> is similar to link selector but for all the forms that davis will bind to</p>

<p><code>throwErrors</code> decides whether or not any errors will be caugth by Davis.  If this is set to true errors will be thrown so that the request will not be handled by JavaScript, the server will have to provide a response.  When set to false errors in a route will be caught and the server will not receive the request.</p>

<p><code>handleRouteNotFound</code> determines whether or not Davis should handle requests when there is no matching route.  If set to false Davis will allow the request to be passed to your server to handle if no matching route can be found.</p>

<p><code>generateRequestOnPageLoad</code> determines whether a request should be generated for the initial page load. by default this is set to false. A Davis.Request will not be generated with the path of the current page.  Setting this to true will cause a request to be passed to your app for the inital page load.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.settings = {
    linkSelector: 'a',
    formSelector: 'form',
    throwErrors: true,
    handleRouteNotFound: false,
    generateRequestOnPageLoad: false
  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='start'>
              <header>
                <h3>start</h3>
                <h4>App.prototype.start()</h4>
                <p class='type'>method</p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Starts the app's routing.</p>

<p>Apps created using the convinience Davis() function are automatically started.</p>

<p>Starting the app binds all links and forms, so clicks and submits create Davis requests that will be pushed onto the browsers history stack.  Browser history change events will be picked up and the request that caused the change will be matched against the apps routes and filters.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.start = function(){
    var self = this;

    if (this.running) return

    if (!Davis.supported()) {
      this.trigger('unsupported')
      return
    };

    var runFilterWith = function (request) {
      return function (filter) {
        var result = filter.run(request, request);
        return (typeof result === &quot;undefined&quot; || result);
      }
    }

    var beforeFiltersPass = function (request) {
      return Davis.utils.every(
        self.lookupBeforeFilter(request.method, request.path),
        runFilterWith(request)
      )
    }

    var handleRequest = function (request) {
      if (beforeFiltersPass(request)) {
        self.trigger('lookupRoute', request)
        var route = self.lookupRoute(request.method, request.path);
        if (route) {
          self.trigger('runRoute', request, route);

          try {
            route.run(request)
            self.trigger('routeComplete', request, route)
          } catch (error) {
            self.trigger('routeError', request, route, error)
          }

          Davis.utils.every(
            self.lookupAfterFilter(request.method, request.path),
            runFilterWith(request)
          );

        } else {
          self.trigger('routeNotFound', request);
        }
      } else {
        self.trigger('requestHalted', request)
      }
    }

    var bindToInternalEvents = function () {
      self
        .bind('runRoute', function (request) {
          self.logger.info(&quot;runRoute: &quot; + request.toString());
        })
        .bind('routeNotFound', function (request) {
          if (!self.settings.handleRouteNotFound &amp;&amp; !request.isForPageLoad) {
            self.stop()
            request.delegateToServer()
          };
          self.logger.warn(&quot;routeNotFound: &quot; + request.toString());
        })
        .bind('start', function () {
          self.logger.info(&quot;application started&quot;)
        })
        .bind('stop', function () {
          self.logger.info(&quot;application stopped&quot;)
        })
        .bind('routeError', function (request, route, error) {
          if (self.settings.throwErrors) throw(error)
          self.logger.error(error.message, error.stack)
        });

      Davis.location.onChange(function (req) {
        handleRequest(req)
      });

      self.boundToInternalEvents = true
    }

    if (!this.boundToInternalEvents) bindToInternalEvents()

    this.listen();
    this.trigger('start')
    this.running = true;

    if (this.settings.generateRequestOnPageLoad) handleRequest(Davis.Request.forPageLoad())

  };</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='stop'>
              <header>
                <h3>stop</h3>
                <h4>App.prototype.stop()</h4>
                <p class='type'>method</p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Stops the app's routing.</p>

<p>Stops the app listening to clicks and submits on all forms and links found using the current apps settings.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>App.prototype.stop = function() {
    this.unlisten();
    this.trigger('stop')
    this.running = false
  };

  return App;
})()</code></pre>
              </section>
              
            </section>
          
        </article>
      
    </div>
  </div>
  <script>
    (function (hijs) {
    //
    // hijs - JavaScript Syntax Highlighter
    //
    // Copyright (c) 2010 Alexis Sellier
    //

    // All elements which match this will be syntax highlighted.
    var selector = hijs || 'code';

    var keywords = ('var function if else for while break switch case do new null in with void '
                   +'continue delete return this true false throw catch typeof with instanceof').split(' '),
        special  = ('eval window document undefined NaN Infinity parseInt parseFloat '
                   +'encodeURI decodeURI encodeURIComponent decodeURIComponent').split(' ');

    // Syntax definition
    // The key becomes the class name of the <span>
    // around the matched block of code.
    var syntax = [
      ['comment', /(\/\*(?:[^*\n]|\*+[^\/*])*\*+\/)/g],
      ['comment', /(\/\/[^\n]*)/g],
      ['string' , /("(?:(?!")[^\\\n]|\\.)*"|'(?:(?!')[^\\\n]|\\.)*')/g],
      ['regexp' , /(\/.+\/[mgi]*)(?!\s*\w)/g],
      ['class'  , /\b([A-Z][a-zA-Z]+)\b/g],
      ['number' , /\b([0-9]+(?:\.[0-9]+)?)\b/g],
      ['keyword', new(RegExp)('\\b(' + keywords.join('|') + ')\\b', 'g')],
      ['special', new(RegExp)('\\b(' + special.join('|') + ')\\b', 'g')]
    ];
    var nodes, table = {};

    if (/^[a-z]+$/.test(selector)) {
        nodes = document.getElementsByTagName(selector);
    } else if (/^\.[\w-]+$/.test(selector)) {
        nodes = document.getElementsByClassName(selector.slice(1));
    } else if (document.querySelectorAll) {
        nodes = document.querySelectorAll(selector);
    } else {
        nodes = [];
    }

    for (var i = 0, children; i < nodes.length; i++) {
        children = nodes[i].childNodes;

        for (var j = 0, str; j < children.length; j++) {
            code = children[j];

            if (code.length >= 0) { // It's a text node
                // Don't highlight command-line snippets
                if (! /^\$/.test(code.nodeValue.trim())) {
                    syntax.forEach(function (s) {
                        var k = s[0], v = s[1];
                        code.nodeValue = code.nodeValue.replace(v, function (_, m) {
                            return '\u00ab' + encode(k) + '\u00b7'
                                            + encode(m) +
                                   '\u00b7' + encode(k) + '\u00bb';
                        });
                    });
                }
            }
        }
    }
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].innerHTML =
            nodes[i].innerHTML.replace(/\u00ab(.+?)\u00b7(.+?)\u00b7\1\u00bb/g, function (_, name, value) {
                value = value.replace(/\u00ab[^\u00b7]+\u00b7/g, '').replace(/\u00b7[^\u00bb]+\u00bb/g, '');
                return '<span class="' + decode(name) + '">' + escape(decode(value)) + '</span>';
        });
    }

    function escape(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Encode ASCII characters to, and from Braille
    function encode (str, encoded) {
        table[encoded = str.split('').map(function (s) {
            if (s.charCodeAt(0) > 127) { return s }
            return String.fromCharCode(s.charCodeAt(0) + 0x2800);
        }).join('')] = str;
        return encoded;
    }
    function decode (str) {
        if (str in table) {
            return table[str];
        } else {
            return str.trim().split('').map(function (s) {
                if (s.charCodeAt(0) - 0x2800 > 127) { return s }
                return String.fromCharCode(s.charCodeAt(0) - 0x2800);
            }).join('');
        }
    }

    })(window.hijs);
  </script>
</body>
